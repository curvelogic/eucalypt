{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"eucalypt eucalypt is a tool, and a little language, for generating and transforming structured data formats like YAML, JSON and TOML. If you use text-based templating to process these formats or you pipe this these formats through several different tools or build steps, eucalypt might be able to help you generate your output more cleanly and with fewer cognitive somersaults. eucalypt is a purely functional language that can be used quickly and easily from the command line. It has the following features: a concise native syntax that allows you to define data, functions, and operators a simple embedding into YAML files to support in-place manipulation of the data (a la templating) facilities for manipulating blocks (think JSON objects, YAML mappings) facilities for manipulating text including string interpolation and regular expressions an ergonomic command line interface and access to environment variables metadata annotations and numerous extension points a prelude of built in functions, acting like a standard library It can currently read YAML, JSON, TOML, XML, CSV and plain text and eucalypt's own (\"eu\") syntax and it can export YAML, JSON, TOML or plain text. Warning eucalypt is still in an early phase of development and subject to change. A lightning tour Eucalypt has a native syntax for writing blocks, lists and expressions. The YAML embedding consists of a few YAML tags used to embed eucalypt expression in YAML so a basic understanding of the native syntax is helpful. A few micro-examples should help give a flavour of eucalypt's native syntax. If you want to follow along, see Getting Started for notes on installation. Example 1 Here is a simple one: target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") You can put this in a file named test.eu and run it with just: eu test.eu This outputs the following YAML: target-zones: - eu-west-1a - eu-west-1b - eu-west-1c As an aside, although we're looking at the native eucalypt syntax here, this example could just as easily be embedded directly in a YAML file using the !eu tag. Pop the following in a test.yaml file and process it with: eu test.yaml . You'll get the same result. target-zones: !eu [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") First, this example illustrates how we apply transformations like map simply by concatenation. This \"pipelining\" or \"catenation\" is the natural way to apply transformations to values in eucalypt. In fact this is simply a function call with the arguments rearranged a bit. In this example, map is a function of two parameters. Its first argument is provided in parentheses and its second argument is the value of what came before. Note Users of languages like Elixir or OCaml may recognise an implicit |> operator here. Clojure users may see an invisible threading macro. Note that writing elements next to each other like this gives you the reverse of what you might expect in Haskell or OCaml or Lisp: we write x f not f x . There is a lot of freedom in eucalypt to express ideas in different ways and develop colorful and cryptic expressions. In a larger or more ambitious language this could be viewed as rope to hang yourself with. Please be careful. The string template, \"eu-west-1{}\" , actually defines a function of one argument that returns a string. The key ingredients here are: the interpolation syntax \"{...}\" which allows values to be inserted into the string the (hidden) use of numeric anaphora in the interpolation syntax ( {0} , {1} , {2} , ...) which cause the string to define a function, not just sequence of characters the use of the unnumbered anaphor ( {} ) which is numbered automatically for us, so in this case, {} is a convenient synonym for {0} - the first argument Note Anaphora crop up in various contexts in eucalypt and are generally preferable to the full generality of lambdas. If the idea is too complex to be expressed with anaphora, it should generally be explicitly named. So: a: 42 \"The answer is {0}\" renders as a: The answer is 42 eucalypt also has expression anaphora and block anaphora Note Users of Groovy or Kotlin may recognise an equivalent of the it parameter. Seasoned Lisp hackers are familiar with anaphoric macros. Clojure users will recognise the % , %1 , %2 forms from #(...) contexts. Unlike % repeated uses of unnumbered anaphora in eucalypt refer to different parameters. \"{}{}\" is a two-argument function which concatenates strings. Back to: target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") The whole line is a declaration . Declarations come in several types - this one is a property declaration . A block is written as a sequence of declarations enclosed in braces. For example: { w: \"foo\" # a string x: 3 # a whole number y: 22.2 # a floaty number z: true # the truth } (The # character introduces a comment which is ignored.) Unlike YAML, indentation is never significant. Unlike JSON, commas are not needed to separate declarations. Instead, the eucalypt parser determines the declarations mainly based on the location of colons. You can write: { x: 1 increment negate y: 2 } ...and eucalypt knows it's two declarations. If that's a bit too crazy for you, then feel free to insert the commas. Eucalypt will accept them. Any of these are okay: ok1: { a: 1 b: 2 c: 3 } ok2: { a: 1, b: 2, c: 3 } ok3: { a: 1, b: 2, c: 3, } Note Unlike Clojure which makes commas optional by treating them as whitespace, Eucalypt demands that if you are going to put commas in, they have to be in the right place, at the end of declarations. So you can use them if you believe it makes things clearer but you are prevented from using them in ways which would misguide. Our target-zones property declaration is at the top level so need not be surrounded by braces. Nevertheless it is in a block: the top level block, known as a unit , that is defined by the file that contains it. You can imagine the braces to be there if you like. As a final point on this example, it is probably worthwhile documenting declarations. eucalypt offers an easy way to do that using declaration metadata which we squeeze in between a leading backtick and the declaration itself: ` \"AZs to deploy alien widgets in\" target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") In fact, all sorts of things can be wedged in there, but if a string appears on its own, it is interpreted as documentation. Example 2 Let's look at another small example: character(name): { resource-name: name created: io.epoch-time } prentice: character(\"Pirate Prentice\") { laser-colour: \"red\" } slothrop: character(\"Tyrone Slothrop\") { eye-count: 7 } We've introduced a new type of declaration here of the form f(x): . This is a function declaration . Remember we saw a property declaration earlier. Eucalypt also has operator declarations but we'll ignore those for now. The function declaration declares a function called character , which accepts a single parameter ( name ) and returns a block containing two properties. Functions, like everything else in eucalypt, are declared in and live in blocks but they are left out when output is rendered, so you won't see them in the YAML or JSON that eucalypt produces. The braces in the definition of character are there to delimit the resulting block - not to define a function body. A function that returned a number would not need them: inc(x): x + 1 # this defines an increment function The next important ingredient in this example is block catenation . Blocks can be treated as functions of a single parameter. When they are applied as functions, the effect is a block merge . We've already seen that functions can be applied to arguments by concatenation. So writing one block after another produces a merged block. It contains the contents of the second block merged \"on top\" of the first. There is more to be said on block merge, but for now: { a: 1 } { b: 2 } evaluates to { a: 1 b: 2 } . and { a: 1 } { a: 2 } evaluates to { a: 2 } . In our example, the resulting YAML is just: prentice: resource-name: Pirate Prentice created: 1526991765 laser-colour: red slothrop: resource-name: Tyrone Slothrop created: 1526991765 eye-count: 7 As you can see, io.epoch-time evaluates to a unix timestamp. This metadata is generated once at launch time, not each time the expression is evaluated. eucalypt the language is a pure functional language, and there are no side-effects or non-deterministic functions (although its command line driver can perform all sorts of side-effects as input to the evaluation and as output from the evaluation and there are one or two dirty tricks in the debugging functions). For this reason, prentice and slothrop will have the same timestamps. Block merge can be a useful means of generating common content in objects. The common content can appear first as in this case, allowing it to be overridden. Or it couple be applied second allowing it to override the existing detail. Or a mixture of both. Many more sophisticated means of combining block data are available too. Note This merge is similar to the effect of merge keys in YAML, where a special << mapping key causes a similar merge to occur. Not all YAML processors support this and nor does eucalypt at present, but it probably will some day. Be aware that eucalypt has nothing like virtual functions. The functions in scope when an expression is created are the ones that are applied. So if you redefine an f like this, in an overriding block... { f(x): x+1 a: f(2) } { f(x): x-2 } ...the definition of a will not see it. a: 3 So block merge is only very loosely related to object oriented inheritance. Also by default you only get a shallow merge - deep merges are provided in the standard prelude. It is possible that a deep merge will become the default for block catenation in future. Many more complicated ways of processing blocks are possible using functions, block anaphora and standard prelude functions. Quick tour of the command line On macOS you can install the eu command line tools using Homebrew with: brew install curvelogic/homebrew-tap/eucalypt Check the version you are running with: eu -v eu is intended to be easy to use for common tasks and does its best to allow you to say what you want succinctly. The intention is to be easy to use in pipelines in combination with other tools like jq . By default, it runs in ergonomic mode which will make a few assumptions in order to allow you to be a little less explicit. It also pulls in user-specific declarations from ~/.eucalypt . For repeatable builds and scripted usage, it is better to turn ergonomic mode off using the -B (--batch-mode) switch. The simplest usage is to specify a eucalypt file to evaluate and leave the default render format (YAML) and output (standard out) alone. > eu test.eu eu with no arguments will generally be taken to specify that input is coming from standard in. So the above is equivalent to: > cat test.eu | eu There is an -x switch to control output format explicitly (setting \"yaml\", \"json\", \"text\", \"csv\" or \"eu\") but for the very common case of requiring JSON output there is a shortcut: > eu test.eu -j You can, of course, redirect standard output to a file but if you specify the output file explicitly (with -o ), eu will infer the output format from the extension: > eu test.eu -o output.json # equivalent to eu test.eu -j > output.json Small snippets of eucalypt can be passed in directly using the -e switch. > eu -e '{ a: 8 * 8 }' The fact that eucalypt makes relatively infrequent use of single quotes makes this straightforward for most shells. By default, eu evaluates the entirety of the loaded source and uses all of it to render the result, leaving out any function values and other non-renderable content. It is possible to select just parts of the eucalypt for rendering: A declaration in the source may be identified as the main target using the :main declaration metadata and we become the part rendered by default. targets may be defined and named using the :target declaration metadata and those targets can then be specified using the -t option to eu The -e option can be used in addition to other source file(s) to identify an expression to be rendered (e.g. eu test.eu -e x.y.z ) So eu 's ability to read JSON and YAML natively combined with the last options give a simple way to pick values out of structured data which can be very handy for \"querying\" services that return YAML or JSON data. > aws s3api list-buckets | eu -e 'Buckets map(lookup(:Name))' There is much more to this story. For instance eu can: accept several inputs to make definitions in earlier inputs available to subsequent inputs eu test1.eu test2.eu test3.eu accept YAML and JSON files as pure data to be merged in: eu data.yaml tools.eu accept YAML or JSON annotated with eucalypt to execute: eu data.yaml override the default extensions: eu yaml@info.txt automatically use Eufile files in the current folder hierarchy See command line for more complete documentation.","title":"Home"},{"location":"#eucalypt","text":"eucalypt is a tool, and a little language, for generating and transforming structured data formats like YAML, JSON and TOML. If you use text-based templating to process these formats or you pipe this these formats through several different tools or build steps, eucalypt might be able to help you generate your output more cleanly and with fewer cognitive somersaults. eucalypt is a purely functional language that can be used quickly and easily from the command line. It has the following features: a concise native syntax that allows you to define data, functions, and operators a simple embedding into YAML files to support in-place manipulation of the data (a la templating) facilities for manipulating blocks (think JSON objects, YAML mappings) facilities for manipulating text including string interpolation and regular expressions an ergonomic command line interface and access to environment variables metadata annotations and numerous extension points a prelude of built in functions, acting like a standard library It can currently read YAML, JSON, TOML, XML, CSV and plain text and eucalypt's own (\"eu\") syntax and it can export YAML, JSON, TOML or plain text. Warning eucalypt is still in an early phase of development and subject to change.","title":"eucalypt"},{"location":"#a-lightning-tour","text":"Eucalypt has a native syntax for writing blocks, lists and expressions. The YAML embedding consists of a few YAML tags used to embed eucalypt expression in YAML so a basic understanding of the native syntax is helpful. A few micro-examples should help give a flavour of eucalypt's native syntax. If you want to follow along, see Getting Started for notes on installation.","title":"A lightning tour"},{"location":"#example-1","text":"Here is a simple one: target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") You can put this in a file named test.eu and run it with just: eu test.eu This outputs the following YAML: target-zones: - eu-west-1a - eu-west-1b - eu-west-1c As an aside, although we're looking at the native eucalypt syntax here, this example could just as easily be embedded directly in a YAML file using the !eu tag. Pop the following in a test.yaml file and process it with: eu test.yaml . You'll get the same result. target-zones: !eu [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") First, this example illustrates how we apply transformations like map simply by concatenation. This \"pipelining\" or \"catenation\" is the natural way to apply transformations to values in eucalypt. In fact this is simply a function call with the arguments rearranged a bit. In this example, map is a function of two parameters. Its first argument is provided in parentheses and its second argument is the value of what came before. Note Users of languages like Elixir or OCaml may recognise an implicit |> operator here. Clojure users may see an invisible threading macro. Note that writing elements next to each other like this gives you the reverse of what you might expect in Haskell or OCaml or Lisp: we write x f not f x . There is a lot of freedom in eucalypt to express ideas in different ways and develop colorful and cryptic expressions. In a larger or more ambitious language this could be viewed as rope to hang yourself with. Please be careful. The string template, \"eu-west-1{}\" , actually defines a function of one argument that returns a string. The key ingredients here are: the interpolation syntax \"{...}\" which allows values to be inserted into the string the (hidden) use of numeric anaphora in the interpolation syntax ( {0} , {1} , {2} , ...) which cause the string to define a function, not just sequence of characters the use of the unnumbered anaphor ( {} ) which is numbered automatically for us, so in this case, {} is a convenient synonym for {0} - the first argument Note Anaphora crop up in various contexts in eucalypt and are generally preferable to the full generality of lambdas. If the idea is too complex to be expressed with anaphora, it should generally be explicitly named. So: a: 42 \"The answer is {0}\" renders as a: The answer is 42 eucalypt also has expression anaphora and block anaphora Note Users of Groovy or Kotlin may recognise an equivalent of the it parameter. Seasoned Lisp hackers are familiar with anaphoric macros. Clojure users will recognise the % , %1 , %2 forms from #(...) contexts. Unlike % repeated uses of unnumbered anaphora in eucalypt refer to different parameters. \"{}{}\" is a two-argument function which concatenates strings. Back to: target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") The whole line is a declaration . Declarations come in several types - this one is a property declaration . A block is written as a sequence of declarations enclosed in braces. For example: { w: \"foo\" # a string x: 3 # a whole number y: 22.2 # a floaty number z: true # the truth } (The # character introduces a comment which is ignored.) Unlike YAML, indentation is never significant. Unlike JSON, commas are not needed to separate declarations. Instead, the eucalypt parser determines the declarations mainly based on the location of colons. You can write: { x: 1 increment negate y: 2 } ...and eucalypt knows it's two declarations. If that's a bit too crazy for you, then feel free to insert the commas. Eucalypt will accept them. Any of these are okay: ok1: { a: 1 b: 2 c: 3 } ok2: { a: 1, b: 2, c: 3 } ok3: { a: 1, b: 2, c: 3, } Note Unlike Clojure which makes commas optional by treating them as whitespace, Eucalypt demands that if you are going to put commas in, they have to be in the right place, at the end of declarations. So you can use them if you believe it makes things clearer but you are prevented from using them in ways which would misguide. Our target-zones property declaration is at the top level so need not be surrounded by braces. Nevertheless it is in a block: the top level block, known as a unit , that is defined by the file that contains it. You can imagine the braces to be there if you like. As a final point on this example, it is probably worthwhile documenting declarations. eucalypt offers an easy way to do that using declaration metadata which we squeeze in between a leading backtick and the declaration itself: ` \"AZs to deploy alien widgets in\" target-zones: [\"a\", \"b\", \"c\"] map(\"eu-west-1{}\") In fact, all sorts of things can be wedged in there, but if a string appears on its own, it is interpreted as documentation.","title":"Example 1"},{"location":"#example-2","text":"Let's look at another small example: character(name): { resource-name: name created: io.epoch-time } prentice: character(\"Pirate Prentice\") { laser-colour: \"red\" } slothrop: character(\"Tyrone Slothrop\") { eye-count: 7 } We've introduced a new type of declaration here of the form f(x): . This is a function declaration . Remember we saw a property declaration earlier. Eucalypt also has operator declarations but we'll ignore those for now. The function declaration declares a function called character , which accepts a single parameter ( name ) and returns a block containing two properties. Functions, like everything else in eucalypt, are declared in and live in blocks but they are left out when output is rendered, so you won't see them in the YAML or JSON that eucalypt produces. The braces in the definition of character are there to delimit the resulting block - not to define a function body. A function that returned a number would not need them: inc(x): x + 1 # this defines an increment function The next important ingredient in this example is block catenation . Blocks can be treated as functions of a single parameter. When they are applied as functions, the effect is a block merge . We've already seen that functions can be applied to arguments by concatenation. So writing one block after another produces a merged block. It contains the contents of the second block merged \"on top\" of the first. There is more to be said on block merge, but for now: { a: 1 } { b: 2 } evaluates to { a: 1 b: 2 } . and { a: 1 } { a: 2 } evaluates to { a: 2 } . In our example, the resulting YAML is just: prentice: resource-name: Pirate Prentice created: 1526991765 laser-colour: red slothrop: resource-name: Tyrone Slothrop created: 1526991765 eye-count: 7 As you can see, io.epoch-time evaluates to a unix timestamp. This metadata is generated once at launch time, not each time the expression is evaluated. eucalypt the language is a pure functional language, and there are no side-effects or non-deterministic functions (although its command line driver can perform all sorts of side-effects as input to the evaluation and as output from the evaluation and there are one or two dirty tricks in the debugging functions). For this reason, prentice and slothrop will have the same timestamps. Block merge can be a useful means of generating common content in objects. The common content can appear first as in this case, allowing it to be overridden. Or it couple be applied second allowing it to override the existing detail. Or a mixture of both. Many more sophisticated means of combining block data are available too. Note This merge is similar to the effect of merge keys in YAML, where a special << mapping key causes a similar merge to occur. Not all YAML processors support this and nor does eucalypt at present, but it probably will some day. Be aware that eucalypt has nothing like virtual functions. The functions in scope when an expression is created are the ones that are applied. So if you redefine an f like this, in an overriding block... { f(x): x+1 a: f(2) } { f(x): x-2 } ...the definition of a will not see it. a: 3 So block merge is only very loosely related to object oriented inheritance. Also by default you only get a shallow merge - deep merges are provided in the standard prelude. It is possible that a deep merge will become the default for block catenation in future. Many more complicated ways of processing blocks are possible using functions, block anaphora and standard prelude functions.","title":"Example 2"},{"location":"#quick-tour-of-the-command-line","text":"On macOS you can install the eu command line tools using Homebrew with: brew install curvelogic/homebrew-tap/eucalypt Check the version you are running with: eu -v eu is intended to be easy to use for common tasks and does its best to allow you to say what you want succinctly. The intention is to be easy to use in pipelines in combination with other tools like jq . By default, it runs in ergonomic mode which will make a few assumptions in order to allow you to be a little less explicit. It also pulls in user-specific declarations from ~/.eucalypt . For repeatable builds and scripted usage, it is better to turn ergonomic mode off using the -B (--batch-mode) switch. The simplest usage is to specify a eucalypt file to evaluate and leave the default render format (YAML) and output (standard out) alone. > eu test.eu eu with no arguments will generally be taken to specify that input is coming from standard in. So the above is equivalent to: > cat test.eu | eu There is an -x switch to control output format explicitly (setting \"yaml\", \"json\", \"text\", \"csv\" or \"eu\") but for the very common case of requiring JSON output there is a shortcut: > eu test.eu -j You can, of course, redirect standard output to a file but if you specify the output file explicitly (with -o ), eu will infer the output format from the extension: > eu test.eu -o output.json # equivalent to eu test.eu -j > output.json Small snippets of eucalypt can be passed in directly using the -e switch. > eu -e '{ a: 8 * 8 }' The fact that eucalypt makes relatively infrequent use of single quotes makes this straightforward for most shells. By default, eu evaluates the entirety of the loaded source and uses all of it to render the result, leaving out any function values and other non-renderable content. It is possible to select just parts of the eucalypt for rendering: A declaration in the source may be identified as the main target using the :main declaration metadata and we become the part rendered by default. targets may be defined and named using the :target declaration metadata and those targets can then be specified using the -t option to eu The -e option can be used in addition to other source file(s) to identify an expression to be rendered (e.g. eu test.eu -e x.y.z ) So eu 's ability to read JSON and YAML natively combined with the last options give a simple way to pick values out of structured data which can be very handy for \"querying\" services that return YAML or JSON data. > aws s3api list-buckets | eu -e 'Buckets map(lookup(:Name))' There is much more to this story. For instance eu can: accept several inputs to make definitions in earlier inputs available to subsequent inputs eu test1.eu test2.eu test3.eu accept YAML and JSON files as pure data to be merged in: eu data.yaml tools.eu accept YAML or JSON annotated with eucalypt to execute: eu data.yaml override the default extensions: eu yaml@info.txt automatically use Eufile files in the current folder hierarchy See command line for more complete documentation.","title":"Quick tour of the command line"},{"location":"anaphora-and-lambdas/","text":"Anaphora and Lambdas Eucalypt doesn't have a lambda syntax in itself and prefers to encourage other approaches in most cases where you would use a lambda. named functions function values from composites, combinators, partials anaphoric expressions, blocks or strings However, through the combination of two Eucalypt features, namely block anaphora and generalised lookup , you can express arbitrary lambdas as we'll see below. The various alternatives are considered one by one. Named functions Very likely, the clearest way to square a list of numbers is to map an explicitly named square function across it. square(x): x * x squares: [1, 2, 3] map(square) //=> [1, 4, 9] The drawbacks of this are: - polluting a namespace with a name that is need only once - arguably, a slightly tedious verbosity The first can be dealt with as follows: squares: { square(x): x * x }.([1, 2, 3] map(square)) //=> [1, 4, 9] This exploits a feature called generalised lookup . Why \"generalised lookup\"? In the simple case below, the dot signifies the \"lookup\" of key a in the block preceding the dot: x: { a: 3 b: 4 }.a //=> 3 We can generalise this by allowing arbitrary expressions in place of the a by evaluating the expression after the dot in the context of the namespace introduced by the block to the left. x: { a: 3 b: 4 }.(a + b) //=> 7 It works for any expression after the dot: x: { a: 3 b: 4 }.[a, b] //=> [3, 4] y: { a: 3 b: 4 }.{ c: a + b } //=> { c: 7 } z: { a: 3 b: 4 }.\"{a} and {b}\" //=> \"3 and 4\" Warning This is very effective for short and simple expressions but quickly gets very complicated and hard to understand if you use it too much. Nested or iterated generalised lookups are usually a bad idea. In the squares example above, generalised lookup is used to restrict the scope in which square is visible right down to the only expression which needs it. However in the case of a simple expression like the squaring example, a neater approach is to use expression anaphora . Expression Anaphora Any expression can become a function by referring to implicit parameters known as expression anaphora. These parameters are called _0 , _1 _2 , and so on. There is also an unnumbered anaphorus, _ , which we'll come back to. Just referring to these parameters is enough to turn an expression into a lambda. So an expression that refers _0 and _1 actually defines a function accepting two parameters: xs: zip-with(f, [1, 2, 3], [1, 2, 3]) //=> [3, 6, 9] # or more succinctly xs: zip-with(_0 + 2 * _1, [1, 2, 3], [1, 2, 3]) //=> [3, 6, 9] Warning Again, anaphora intended for use in simple cases where they are readable and readily understood. The scope of the implicit parameters is not easy to work out in complicated contexts. (It does not extend past catenation or commas in lists or function application tuples.) Anaphoric expressions are not, and not intended to be, a fully general lambda syntax. Unlike explicit lambda constructions, you cannot nest anaphoric expressions. squares: [1, 2, 3] map(_0 * _0) //=> [1, 4, 9] In cases where the position of the anaphora in the expression matches the parameter positions in the function call, you can omit the numbers. So, for instance, _0 + _1 can simply be written _ + _ , and _0 * _1 + x * _2 can be written _ * _ + x * _ . Each _ represents a different implicit parameter, which is why we had to write _0 * _0 in our squares example - it was important that the same parameter was reference twice. Sometime you need explicit parentheses to clarify the scope of expression anaphora: block: { a: 1 b: 2 } x: block (_.a) //=> 1 y: block lookup(:a) //=> 1 # # BUT NOT: block _.a # Sections Even more conciseness is on offer in some cases where the anaphora can be entirely omitted. Eucalypt will automatically insert anaphora when it detects gaps in an expression based on its knowledge of an operator's type. So it will automatically read (1 +) as (1 + _) , for example, defining a function of one parameter. Or (*) as (_ * _) , defining a function of two parameters. The parentheses may not even be necessary to delimit the expression: x: foldl(+, 0, [1, 2, 3]) = 6 Again, use of sections is recommended only for short expressions or where the intention is obvious. This level of tersity can lead to baffling code if abused. Block Anaphora Expression anaphora are scoped by an expression which is roughly defined as something within parentheses or something which can be the right hand side of a declaration. Sometimes however you would like to define a block-valued function. Imagine you wanted a two-parameter function which placed the parameters in a block with keys x and y : f(x, y): {x: x y: y } An attempt to define this using expression anaphora would fail. This defines a block with two identity functions: f: {x: _ y: _ } Instead, you can use block anaphora which are scoped by the block that contains them. The block anaphora are named \u20220 , \u20221 , \u20222 with a special unnumbered anaphor \u2022 , playing the same role as _ does for expression anaphora. \u2022 is the BULLET character (usually Option-8 on a Mac but you may find other convenient ways to type it). The slightly awkward character is chosen firstly because it looks like a hole and therefore makes sense as a placeholder, and secondly to discourage overuse of the feature... The following defines the function we want f: { x: \u2022 y: \u2022 } ...and can, of course, be used x: [[1, 2], [3, 4], [5, 6]] map({ x: \u2022 y: \u2022 } uncurry) Pseudo-lambdas Astute observers may realise that by combining generalised lookup and block anaphora you end up with something that's not a million miles away from a lambda syntax: f: { x: \u2022 y: \u2022 }.(x + y) Indeed this does allow declaration of anonymous functions with named parameters and can occasionally be useful but it still falls short of a fully general lambda construction because it cannot (at least for now) be nested. String Anaphora Analogously, Eucalypt's string interpolation syntax allows the use of anaphora {0} , {1} , {2} and the unnumbered {} to define functions which return strings. x: [1, 2, 3] map(\"#{}\") //=> [\"#1\", \"#2\", \"#3\"] Summary There are lots of ways to define functions but the clearest is just defining them with names using function declarations and for anything even slightly complicated this should be the default. The only things you should be tempted to define on the spot are things that are simple enough that the various species of anaphora can handle them neatly.","title":"Anaphora and Lambdas"},{"location":"anaphora-and-lambdas/#anaphora-and-lambdas","text":"Eucalypt doesn't have a lambda syntax in itself and prefers to encourage other approaches in most cases where you would use a lambda. named functions function values from composites, combinators, partials anaphoric expressions, blocks or strings However, through the combination of two Eucalypt features, namely block anaphora and generalised lookup , you can express arbitrary lambdas as we'll see below. The various alternatives are considered one by one.","title":"Anaphora and Lambdas"},{"location":"anaphora-and-lambdas/#named-functions","text":"Very likely, the clearest way to square a list of numbers is to map an explicitly named square function across it. square(x): x * x squares: [1, 2, 3] map(square) //=> [1, 4, 9] The drawbacks of this are: - polluting a namespace with a name that is need only once - arguably, a slightly tedious verbosity The first can be dealt with as follows: squares: { square(x): x * x }.([1, 2, 3] map(square)) //=> [1, 4, 9] This exploits a feature called generalised lookup . Why \"generalised lookup\"? In the simple case below, the dot signifies the \"lookup\" of key a in the block preceding the dot: x: { a: 3 b: 4 }.a //=> 3 We can generalise this by allowing arbitrary expressions in place of the a by evaluating the expression after the dot in the context of the namespace introduced by the block to the left. x: { a: 3 b: 4 }.(a + b) //=> 7 It works for any expression after the dot: x: { a: 3 b: 4 }.[a, b] //=> [3, 4] y: { a: 3 b: 4 }.{ c: a + b } //=> { c: 7 } z: { a: 3 b: 4 }.\"{a} and {b}\" //=> \"3 and 4\" Warning This is very effective for short and simple expressions but quickly gets very complicated and hard to understand if you use it too much. Nested or iterated generalised lookups are usually a bad idea. In the squares example above, generalised lookup is used to restrict the scope in which square is visible right down to the only expression which needs it. However in the case of a simple expression like the squaring example, a neater approach is to use expression anaphora .","title":"Named functions"},{"location":"anaphora-and-lambdas/#expression-anaphora","text":"Any expression can become a function by referring to implicit parameters known as expression anaphora. These parameters are called _0 , _1 _2 , and so on. There is also an unnumbered anaphorus, _ , which we'll come back to. Just referring to these parameters is enough to turn an expression into a lambda. So an expression that refers _0 and _1 actually defines a function accepting two parameters: xs: zip-with(f, [1, 2, 3], [1, 2, 3]) //=> [3, 6, 9] # or more succinctly xs: zip-with(_0 + 2 * _1, [1, 2, 3], [1, 2, 3]) //=> [3, 6, 9] Warning Again, anaphora intended for use in simple cases where they are readable and readily understood. The scope of the implicit parameters is not easy to work out in complicated contexts. (It does not extend past catenation or commas in lists or function application tuples.) Anaphoric expressions are not, and not intended to be, a fully general lambda syntax. Unlike explicit lambda constructions, you cannot nest anaphoric expressions. squares: [1, 2, 3] map(_0 * _0) //=> [1, 4, 9] In cases where the position of the anaphora in the expression matches the parameter positions in the function call, you can omit the numbers. So, for instance, _0 + _1 can simply be written _ + _ , and _0 * _1 + x * _2 can be written _ * _ + x * _ . Each _ represents a different implicit parameter, which is why we had to write _0 * _0 in our squares example - it was important that the same parameter was reference twice. Sometime you need explicit parentheses to clarify the scope of expression anaphora: block: { a: 1 b: 2 } x: block (_.a) //=> 1 y: block lookup(:a) //=> 1 # # BUT NOT: block _.a #","title":"Expression Anaphora"},{"location":"anaphora-and-lambdas/#sections","text":"Even more conciseness is on offer in some cases where the anaphora can be entirely omitted. Eucalypt will automatically insert anaphora when it detects gaps in an expression based on its knowledge of an operator's type. So it will automatically read (1 +) as (1 + _) , for example, defining a function of one parameter. Or (*) as (_ * _) , defining a function of two parameters. The parentheses may not even be necessary to delimit the expression: x: foldl(+, 0, [1, 2, 3]) = 6 Again, use of sections is recommended only for short expressions or where the intention is obvious. This level of tersity can lead to baffling code if abused.","title":"Sections"},{"location":"anaphora-and-lambdas/#block-anaphora","text":"Expression anaphora are scoped by an expression which is roughly defined as something within parentheses or something which can be the right hand side of a declaration. Sometimes however you would like to define a block-valued function. Imagine you wanted a two-parameter function which placed the parameters in a block with keys x and y : f(x, y): {x: x y: y } An attempt to define this using expression anaphora would fail. This defines a block with two identity functions: f: {x: _ y: _ } Instead, you can use block anaphora which are scoped by the block that contains them. The block anaphora are named \u20220 , \u20221 , \u20222 with a special unnumbered anaphor \u2022 , playing the same role as _ does for expression anaphora. \u2022 is the BULLET character (usually Option-8 on a Mac but you may find other convenient ways to type it). The slightly awkward character is chosen firstly because it looks like a hole and therefore makes sense as a placeholder, and secondly to discourage overuse of the feature... The following defines the function we want f: { x: \u2022 y: \u2022 } ...and can, of course, be used x: [[1, 2], [3, 4], [5, 6]] map({ x: \u2022 y: \u2022 } uncurry)","title":"Block Anaphora"},{"location":"anaphora-and-lambdas/#pseudo-lambdas","text":"Astute observers may realise that by combining generalised lookup and block anaphora you end up with something that's not a million miles away from a lambda syntax: f: { x: \u2022 y: \u2022 }.(x + y) Indeed this does allow declaration of anonymous functions with named parameters and can occasionally be useful but it still falls short of a fully general lambda construction because it cannot (at least for now) be nested.","title":"Pseudo-lambdas"},{"location":"anaphora-and-lambdas/#string-anaphora","text":"Analogously, Eucalypt's string interpolation syntax allows the use of anaphora {0} , {1} , {2} and the unnumbered {} to define functions which return strings. x: [1, 2, 3] map(\"#{}\") //=> [\"#1\", \"#2\", \"#3\"]","title":"String Anaphora"},{"location":"anaphora-and-lambdas/#summary","text":"There are lots of ways to define functions but the clearest is just defining them with names using function declarations and for anything even slightly complicated this should be the default. The only things you should be tempted to define on the spot are things that are simple enough that the various species of anaphora can handle them neatly.","title":"Summary"},{"location":"command-line/","text":"eu command line Eucalypt is available as a command line tool, eu , which reads inputs and writes outputs. Everything it does in between is purely functional and there is no mutable state. It is intended to be simple to use in unix pipelines. eu --version # shows the current eu version eu --help # lists command line options Inputs Files / stdin eu can read several inputs, specified by command line arguments. Inputs specify text data from: files stdin internal resources (ignored for now) (in future) HTTPS URLS or Git refs ...of which the first two are the common case. In the simplest case, file inputs are specified by file name, stdin is specified by - . So eu a.yaml - b.eu ...will read input from a.yaml , stdin and b.eu . Each will be read into eucalypt 's core representation and merged before output is rendered. Input format Inputs must be one of the formats that eucalypt supports, which at present, are: yaml json toml csv text Of these the first three (yaml, json, toml) return blocks and the last two return lists. Inputs that return lists frequently to be named (see below) to allow them to be used. Usually the format is inferred from file extension but it can be overridden on an input by input basis using a format@ prefix. For instance: eu yaml@a.txt json@- yaml@b.txt ...will read YAML from a.txt , JSON from stdin and YAML from b.txt . Named inputs Finally inputs can be named using a name= prefix. This alters the way that data is merged by making the contents of an input available in a block or list with the specified name, instead of at the top level. Suppose we have two inputs: foo: bar x: 42 then eu a.yaml b.eu would generate: foo: bar x: 42 but eu data=a.yaml b.eu would generate: data: foo: bar x: 42 This can be useful for various reasons, particularly when: the form of the input's content is not known in advance the input's content is a list rather than a block Full input syntax The full input syntax is therefore: [name=][format@][URL/file] This applies at the command line and also when specifying imports in .eu files. stdin defaulting When no inputs are specified and eu is being used in a pipeline, it will accept input from stdin by default, making it easy to pipe JSON or YAML from other tools into eu. For example, this takes JSON from the aws CLI and formats it as YAML to stdout. aws s3-api list-buckets | eu How inputs are merged When several inputs are listed, names from earlier inputs become available to later inputs, but the content that will be rendered is that of the final input. So for instance: a.eu x: 4 y: 8 b.eu z: x + y eu a.eu b.eu will output z: 12 The common use cases are: - a final input containing logic to inspect or process data provided by previous inputs - a final input which uses functions defined in earlier inputs to process data provided in previous inputs If you want to __render_ contents of earlier inputs, you need a named input to provide a name for that content which you can then use. For instance: eu r=a.eu b.eu -e r will render: x: 4 y: 8 --collect-as and --name-inputs Occasionally it is useful to aggregate data from an arbitrary number of sources files, typically specified by shell wildcards. To refer to this data we need to introduce a name for the collection of data. This is what the command line switch --collect-as / -C is for. eu --collect-as inputs *.eu ...will render: inputs: - x: 4 y: 8 - z: 12 It is common to use -e to select an item to render: eu -C *.eu -e 'inputs head' ...renders: x: 4 y: 8 If you are likely to need to refer to inputs by name, you can add --name-inputs / -N to pass inputs as a block instead of a list: eu --collect-as inputs *.eu ...renders: inputs: a.eu: x: 4 y: 8 b.eu: z: 12 This makes it possible to easier to invoke specific functions from named inputs although you will need single-quote name syntax to use the generated names which contain '.'s. Outputs In the current version, eu can only generate one output. Output format Output is rendered as YAML by default. Other formats can be specified using the -x command line option: eu -x json # for JSON eu -x text # for plain text JSON is such a common case that there is a shortcut: -j . Output targets By default, eucalypt renders all the content of the final input to output. There are various ways to override this. First, :target metadata can be specified in the final input to identify different parts for potential export. To list the targets found in the specified inputs, use the -t flag. eu -l ...and a particular target can be selected for render using -t . eu -t my-target If there is a target called \"main\" it will be used by default unless another target is specified. Evaluands In addition to inputs, an evaluand can be specified at the command line. This is a eucalypt expression which has access to all names defined in the inputs and replaces the input body or targets as the data to export. It can be used to select content or derive values from data in the inputs: $ aws s3api list-buckets | eu -e 'Buckets map(lookup(:CreationDate)) head' 2016-12-25T14:22:30.000Z ...or just to test out short expressions or command line features: $ eu -e '{a: 1 b: 2 * 2}' -j {\"a\": 1, \"b\": 4} Suppressing prelude A standard prelude containing many functions and operators is automatically prepended to the input list. This can be suppressed using -Q if it is not required or if you would like to provide an alternative. Warning Many very basic facilities - like the definition of true and false and if - are provided by the prelude so suppressing it leaves a very bare environment. Debugging eu has a variety of command line switches for dumping out internal representations or tracing execution. eu --help lists them all.","title":"Command Line"},{"location":"command-line/#eu-command-line","text":"Eucalypt is available as a command line tool, eu , which reads inputs and writes outputs. Everything it does in between is purely functional and there is no mutable state. It is intended to be simple to use in unix pipelines. eu --version # shows the current eu version eu --help # lists command line options","title":"eu command line"},{"location":"command-line/#inputs","text":"","title":"Inputs"},{"location":"command-line/#files-stdin","text":"eu can read several inputs, specified by command line arguments. Inputs specify text data from: files stdin internal resources (ignored for now) (in future) HTTPS URLS or Git refs ...of which the first two are the common case. In the simplest case, file inputs are specified by file name, stdin is specified by - . So eu a.yaml - b.eu ...will read input from a.yaml , stdin and b.eu . Each will be read into eucalypt 's core representation and merged before output is rendered.","title":"Files / stdin"},{"location":"command-line/#input-format","text":"Inputs must be one of the formats that eucalypt supports, which at present, are: yaml json toml csv text Of these the first three (yaml, json, toml) return blocks and the last two return lists. Inputs that return lists frequently to be named (see below) to allow them to be used. Usually the format is inferred from file extension but it can be overridden on an input by input basis using a format@ prefix. For instance: eu yaml@a.txt json@- yaml@b.txt ...will read YAML from a.txt , JSON from stdin and YAML from b.txt .","title":"Input format"},{"location":"command-line/#named-inputs","text":"Finally inputs can be named using a name= prefix. This alters the way that data is merged by making the contents of an input available in a block or list with the specified name, instead of at the top level. Suppose we have two inputs: foo: bar x: 42 then eu a.yaml b.eu would generate: foo: bar x: 42 but eu data=a.yaml b.eu would generate: data: foo: bar x: 42 This can be useful for various reasons, particularly when: the form of the input's content is not known in advance the input's content is a list rather than a block","title":"Named inputs"},{"location":"command-line/#full-input-syntax","text":"The full input syntax is therefore: [name=][format@][URL/file] This applies at the command line and also when specifying imports in .eu files.","title":"Full input syntax"},{"location":"command-line/#stdin-defaulting","text":"When no inputs are specified and eu is being used in a pipeline, it will accept input from stdin by default, making it easy to pipe JSON or YAML from other tools into eu. For example, this takes JSON from the aws CLI and formats it as YAML to stdout. aws s3-api list-buckets | eu","title":"stdin defaulting"},{"location":"command-line/#how-inputs-are-merged","text":"When several inputs are listed, names from earlier inputs become available to later inputs, but the content that will be rendered is that of the final input. So for instance: a.eu x: 4 y: 8 b.eu z: x + y eu a.eu b.eu will output z: 12 The common use cases are: - a final input containing logic to inspect or process data provided by previous inputs - a final input which uses functions defined in earlier inputs to process data provided in previous inputs If you want to __render_ contents of earlier inputs, you need a named input to provide a name for that content which you can then use. For instance: eu r=a.eu b.eu -e r will render: x: 4 y: 8","title":"How inputs are merged"},{"location":"command-line/#-collect-as-and-name-inputs","text":"Occasionally it is useful to aggregate data from an arbitrary number of sources files, typically specified by shell wildcards. To refer to this data we need to introduce a name for the collection of data. This is what the command line switch --collect-as / -C is for. eu --collect-as inputs *.eu ...will render: inputs: - x: 4 y: 8 - z: 12 It is common to use -e to select an item to render: eu -C *.eu -e 'inputs head' ...renders: x: 4 y: 8 If you are likely to need to refer to inputs by name, you can add --name-inputs / -N to pass inputs as a block instead of a list: eu --collect-as inputs *.eu ...renders: inputs: a.eu: x: 4 y: 8 b.eu: z: 12 This makes it possible to easier to invoke specific functions from named inputs although you will need single-quote name syntax to use the generated names which contain '.'s.","title":"--collect-as and --name-inputs"},{"location":"command-line/#outputs","text":"In the current version, eu can only generate one output.","title":"Outputs"},{"location":"command-line/#output-format","text":"Output is rendered as YAML by default. Other formats can be specified using the -x command line option: eu -x json # for JSON eu -x text # for plain text JSON is such a common case that there is a shortcut: -j .","title":"Output format"},{"location":"command-line/#output-targets","text":"By default, eucalypt renders all the content of the final input to output. There are various ways to override this. First, :target metadata can be specified in the final input to identify different parts for potential export. To list the targets found in the specified inputs, use the -t flag. eu -l ...and a particular target can be selected for render using -t . eu -t my-target If there is a target called \"main\" it will be used by default unless another target is specified.","title":"Output targets"},{"location":"command-line/#evaluands","text":"In addition to inputs, an evaluand can be specified at the command line. This is a eucalypt expression which has access to all names defined in the inputs and replaces the input body or targets as the data to export. It can be used to select content or derive values from data in the inputs: $ aws s3api list-buckets | eu -e 'Buckets map(lookup(:CreationDate)) head' 2016-12-25T14:22:30.000Z ...or just to test out short expressions or command line features: $ eu -e '{a: 1 b: 2 * 2}' -j {\"a\": 1, \"b\": 4}","title":"Evaluands"},{"location":"command-line/#suppressing-prelude","text":"A standard prelude containing many functions and operators is automatically prepended to the input list. This can be suppressed using -Q if it is not required or if you would like to provide an alternative. Warning Many very basic facilities - like the definition of true and false and if - are provided by the prelude so suppressing it leaves a very bare environment.","title":"Suppressing prelude"},{"location":"command-line/#debugging","text":"eu has a variety of command line switches for dumping out internal representations or tracing execution. eu --help lists them all.","title":"Debugging"},{"location":"getting-started/","text":"Installation The current implementation of eucalypt is available in the eucalypt project and can be installed as follows. On macOS via Homebrew If you use homebrew, you can install using brew install curvelogic/homebrew-tap/eucalypt Otherwise binaries for macOS x86_64 are available on the releases page . No binaries are available for Apple Silicon yet. On Linux x86_64 binaries built in CI are available on the releases page On Windows Sorry, haven't got there yet. But you could try installing from source. From source You will need a rust installation and cargo . Build and install should be as simple as: cargo install --path . Testing your installation eu --version ...prints the version: $ eu --version eu - Eucalypt (Rust Impl: v0.2.0.0) ...and... eu --help ...shows command line help: reu 0.2.0 Option to select the command actually run USAGE: eu [FLAGS] [OPTIONS] [--] [inputs]... FLAGS: -d, --debug Turn on debug features --dump-cooked Dump core expression once operator soup has been analysed for precedence --dump-desugared Dump core expression as initially translated from syntax tree --dump-inlined Dump core expression once inliner pass has run --dump-pruned Dump core expression once dead ocde has been eliminated --dump-runtime Dump code for runtime globals --dump-stg Dump compiled STG syntax -n, --explain Explain command (do not run) -h, --help Prints help information -j Shortcut for `-x json`` -l, --list-targets List targets defined in the source -B, --batch Batch mode (no .eucalypt.d) -Q, --no-prelude Don't load the standard prelude -p, --parse Parse only --quote-debug When outputing AST or Core expressions, quote as debug print of structure --quote-embed When outputing AST or Core expressions, quote-embed as eucalypt -S, --statistics Print metrics to stderr before exiting -T, --test Run file as test -v, --version Explain command (do not run) OPTIONS: -e, --evaluate <evaluate> Expression to evaluate -x, --export-type <export-type> Format to export output in (e.g. yaml, json, toml, text) -L, --lib-path <lib-path>... Add directory to lib path -o <output> Output file to export to -t, --target <target> Target to run (identified by target metadata in eucalypt source) ARGS: <inputs>... Source code / data inputs (in order)","title":"Getting Started"},{"location":"getting-started/#installation","text":"The current implementation of eucalypt is available in the eucalypt project and can be installed as follows.","title":"Installation"},{"location":"getting-started/#on-macos-via-homebrew","text":"If you use homebrew, you can install using brew install curvelogic/homebrew-tap/eucalypt Otherwise binaries for macOS x86_64 are available on the releases page . No binaries are available for Apple Silicon yet.","title":"On macOS via Homebrew"},{"location":"getting-started/#on-linux","text":"x86_64 binaries built in CI are available on the releases page","title":"On Linux"},{"location":"getting-started/#on-windows","text":"Sorry, haven't got there yet. But you could try installing from source.","title":"On Windows"},{"location":"getting-started/#from-source","text":"You will need a rust installation and cargo . Build and install should be as simple as: cargo install --path .","title":"From source"},{"location":"getting-started/#testing-your-installation","text":"eu --version ...prints the version: $ eu --version eu - Eucalypt (Rust Impl: v0.2.0.0) ...and... eu --help ...shows command line help: reu 0.2.0 Option to select the command actually run USAGE: eu [FLAGS] [OPTIONS] [--] [inputs]... FLAGS: -d, --debug Turn on debug features --dump-cooked Dump core expression once operator soup has been analysed for precedence --dump-desugared Dump core expression as initially translated from syntax tree --dump-inlined Dump core expression once inliner pass has run --dump-pruned Dump core expression once dead ocde has been eliminated --dump-runtime Dump code for runtime globals --dump-stg Dump compiled STG syntax -n, --explain Explain command (do not run) -h, --help Prints help information -j Shortcut for `-x json`` -l, --list-targets List targets defined in the source -B, --batch Batch mode (no .eucalypt.d) -Q, --no-prelude Don't load the standard prelude -p, --parse Parse only --quote-debug When outputing AST or Core expressions, quote as debug print of structure --quote-embed When outputing AST or Core expressions, quote-embed as eucalypt -S, --statistics Print metrics to stderr before exiting -T, --test Run file as test -v, --version Explain command (do not run) OPTIONS: -e, --evaluate <evaluate> Expression to evaluate -x, --export-type <export-type> Format to export output in (e.g. yaml, json, toml, text) -L, --lib-path <lib-path>... Add directory to lib path -o <output> Output file to export to -t, --target <target> Target to run (identified by target metadata in eucalypt source) ARGS: <inputs>... Source code / data inputs (in order)","title":"Testing your installation"},{"location":"implementation/","text":"Eucalypt implementation Since v0.2 , Eucalypt has been written in Rust . This replaces a previous 0.1.x implementation in Haskell. When you run eu , execution proceeds in several phases: parsing inputs to abstract syntax trees transformation into a core syntax and merging and manipulation of these representations compilation into STG syntax execution which is interpretation of the STG syntax by the STG machine The core syntax facilitates experimentation by allow powerful features to be implemented simply by syntax transformation (e.g. user definable operator precedence, block catenation). It is also in transformation to core syntax that the two roles of blocks in Eucalypt (name binding and data structuring) are peeled apart into separate elements (a recursive let and a data structure). The interpreter is modeled on an eval-apply STG (spineless tagless G-machine) implementation just to have a well-defined reference point in view for a lazy functional language abstract machine, not for any other reason (concurrency etc.) Ultimately it might well be quicker and clearer to tree-walk the core representation. After some experimentation with cycle collectors, the current implementation deliberately leaks memory until a custom allocator and GC can be implemented. This suits most current uses just fine. Diagnostics Raw ASTs can be dumped (as JSON) using the -p command line switch. Execution can be traced out using the -d debug switch. Core syntax can be dumped at various stages using a variety of --dump-xxx command line switches. STG syntax wrappers for intrinsic functions can be viewed with --dump-runtime . The final STG syntax which is executed by the STG machine may be dumped using --dump-stg .","title":"Implementation"},{"location":"implementation/#eucalypt-implementation","text":"Since v0.2 , Eucalypt has been written in Rust . This replaces a previous 0.1.x implementation in Haskell. When you run eu , execution proceeds in several phases: parsing inputs to abstract syntax trees transformation into a core syntax and merging and manipulation of these representations compilation into STG syntax execution which is interpretation of the STG syntax by the STG machine The core syntax facilitates experimentation by allow powerful features to be implemented simply by syntax transformation (e.g. user definable operator precedence, block catenation). It is also in transformation to core syntax that the two roles of blocks in Eucalypt (name binding and data structuring) are peeled apart into separate elements (a recursive let and a data structure). The interpreter is modeled on an eval-apply STG (spineless tagless G-machine) implementation just to have a well-defined reference point in view for a lazy functional language abstract machine, not for any other reason (concurrency etc.) Ultimately it might well be quicker and clearer to tree-walk the core representation. After some experimentation with cycle collectors, the current implementation deliberately leaks memory until a custom allocator and GC can be implemented. This suits most current uses just fine.","title":"Eucalypt implementation"},{"location":"implementation/#diagnostics","text":"Raw ASTs can be dumped (as JSON) using the -p command line switch. Execution can be traced out using the -d debug switch. Core syntax can be dumped at various stages using a variety of --dump-xxx command line switches. STG syntax wrappers for intrinsic functions can be viewed with --dump-runtime . The final STG syntax which is executed by the STG machine may be dumped using --dump-stg .","title":"Diagnostics"},{"location":"imports/","text":"Imports Eucalypt supports importing content from other units in a variety of ways. Imported names can be scoped to specific declarations, they may be made accessible under a specific namespace, and they may be imported from disk or direct from git repositories. Import scopes Imports are specified in declaration metadata and make the names in the imported unit available within the declaration that is annotated. { import: \"config.eu\" } data: { # names from config are available here x: config-value } As described in syntax , declaration metadata can be applied at a unit level simply by including a metadata block as the very first thing in a eucalypt file: { import: \"config.eu\" } # names from config are available here x: config-value Import syntax Imports are specified using the key import in a declaration metadata block. The value may be a single import specification: { import: \"dep-a.eu\"} or a list of import specifications: { import: [\"dep-a.eu\", \"dep-b.eu\"]} The import specification itself can be either a simple import or a git import . Simple imports Simple imports are specified in exactly the same way as inputs are specified at the command line (see command line ). So you can override the format of the imported file when the file extension is misleading: { import: \"yaml@dep.txt\" } ...and provide a name under which the imported names will be available: { import: \"cfg=config.eu\" } # names in config.eu are available by lookup in cfg: x: cfg.x In cases, where the import format delivers a list rather than a block (\"text\", \"csv\", ...) a name is mandatory: { import: \"txns=transactions.csv\" } Simple imports support exactly the same inputs as the command line, with the proviso that the stdin input (\"-\") will not be consumable if it has already been specified in the command line or another unit. Git imports Git imports allow you to import eucalypt direct from a git repository at a specified commit, combining the convenience of not having to explicitly manage a git working copy and a library path with the repeatability of a git SHA. A git import is specified as a block with the keys \"git\", \"commit\" and \"import\", all of which are mandatory: { import: { git: \"https://github.com/gmorpheme/eu.aws\" commit: \"0140232cf882a922bdd67b520ed56f0cddbd0637\" import: \"aws/cloudformation.eu\" } } The git URL may be any format that the git command line expects. commit is required and should be a SHA. It is intended to ensure the import is repeatable and cacheable. import identifies the file within the repository to import. Just as with simple imports, several git imports may be listed: { import: [{ git: ... }, { git: ... }]} ...and simple imports and git imports may be freely mixed.","title":"Imports"},{"location":"imports/#imports","text":"Eucalypt supports importing content from other units in a variety of ways. Imported names can be scoped to specific declarations, they may be made accessible under a specific namespace, and they may be imported from disk or direct from git repositories.","title":"Imports"},{"location":"imports/#import-scopes","text":"Imports are specified in declaration metadata and make the names in the imported unit available within the declaration that is annotated. { import: \"config.eu\" } data: { # names from config are available here x: config-value } As described in syntax , declaration metadata can be applied at a unit level simply by including a metadata block as the very first thing in a eucalypt file: { import: \"config.eu\" } # names from config are available here x: config-value","title":"Import scopes"},{"location":"imports/#import-syntax","text":"Imports are specified using the key import in a declaration metadata block. The value may be a single import specification: { import: \"dep-a.eu\"} or a list of import specifications: { import: [\"dep-a.eu\", \"dep-b.eu\"]} The import specification itself can be either a simple import or a git import .","title":"Import syntax"},{"location":"imports/#simple-imports","text":"Simple imports are specified in exactly the same way as inputs are specified at the command line (see command line ). So you can override the format of the imported file when the file extension is misleading: { import: \"yaml@dep.txt\" } ...and provide a name under which the imported names will be available: { import: \"cfg=config.eu\" } # names in config.eu are available by lookup in cfg: x: cfg.x In cases, where the import format delivers a list rather than a block (\"text\", \"csv\", ...) a name is mandatory: { import: \"txns=transactions.csv\" } Simple imports support exactly the same inputs as the command line, with the proviso that the stdin input (\"-\") will not be consumable if it has already been specified in the command line or another unit.","title":"Simple imports"},{"location":"imports/#git-imports","text":"Git imports allow you to import eucalypt direct from a git repository at a specified commit, combining the convenience of not having to explicitly manage a git working copy and a library path with the repeatability of a git SHA. A git import is specified as a block with the keys \"git\", \"commit\" and \"import\", all of which are mandatory: { import: { git: \"https://github.com/gmorpheme/eu.aws\" commit: \"0140232cf882a922bdd67b520ed56f0cddbd0637\" import: \"aws/cloudformation.eu\" } } The git URL may be any format that the git command line expects. commit is required and should be a SHA. It is intended to ensure the import is repeatable and cacheable. import identifies the file within the repository to import. Just as with simple imports, several git imports may be listed: { import: [{ git: ... }, { git: ... }]} ...and simple imports and git imports may be freely mixed.","title":"Git imports"},{"location":"operators-and-identifiers/","text":"Operators and Identifiers Eucalypt distinguishes two different types of identifier, normal identifiers, like x , y , \u03b1 , \u05d0 , ziggety-zaggety , zoom? , and operator identifiers like * , @ , && , \u2227 , \u2218 , \u2299\u2299\u2299 , <> and so on. It is entirely a matter of the component characters which category and identifier falls into. Normal identifiers contain letters (including non-ascii characters), numbers, \"-\", \"?\", \"$\". Operator identifiers contain the usual suspects and anything identified as an operator or symbol in unicode. Neither can contain \":\" or \",\" or brackets which are special in eucalypt. Any sequence of characters at all can be treated as a normal identifier by surrounding them in single quotes. This is the only use of single quotes in eucalypt. This can be useful when you want to use file paths or other external identifiers as block keys for instance: home: { '.bashrc': false '.emacs.d': false 'notes.txt': true } z: home.'notes.txt' Normal identifiers Normal operators are brought into scope by declarations and can be referred to without qualification in their own block or in more nested blocks: x: { z: 99 foo: z //=> 99 bar: { y: z //=> 99 } } They can be accessed from within other blocks using the lookup operator: x: { z: 99 } y: x.z //=> 99 They can be overridden using generalised lookup: z: 99 y: { z: 100 }.\"z is {z}\" //=> \"z is 100\" They can be shadowed: z: 99 y: { z: 100 r: z //=> 100 } But beware trying to access the outer value: name: \"foo\" x: { name: name } //=> infinite recursion Accessing shadowed values is not yet easily possible unless you can refer to an enclosing block and use a lookup. Operator identifiers Operator identifiers are more limited than normal identifiers. They are brought into scope by operator declarations and available without qualification in their own block and more nested blocks: ( l -->> r): \"{l} shoots arrow at {r}\" x: { y: 2 -->> 3 //=> \"2 shoots arrow at 3\" } ...and can be shadowed: (l !!! r): l + r y: { (l !!! r): l - r z: 100 !!! 1 //=> 99 } But: they cannot be accessed by lookup, so there is no way of forming a qualified name to access an operator they cannot be overridden by generalised lookup","title":"Operators and Identifiers"},{"location":"operators-and-identifiers/#operators-and-identifiers","text":"Eucalypt distinguishes two different types of identifier, normal identifiers, like x , y , \u03b1 , \u05d0 , ziggety-zaggety , zoom? , and operator identifiers like * , @ , && , \u2227 , \u2218 , \u2299\u2299\u2299 , <> and so on. It is entirely a matter of the component characters which category and identifier falls into. Normal identifiers contain letters (including non-ascii characters), numbers, \"-\", \"?\", \"$\". Operator identifiers contain the usual suspects and anything identified as an operator or symbol in unicode. Neither can contain \":\" or \",\" or brackets which are special in eucalypt. Any sequence of characters at all can be treated as a normal identifier by surrounding them in single quotes. This is the only use of single quotes in eucalypt. This can be useful when you want to use file paths or other external identifiers as block keys for instance: home: { '.bashrc': false '.emacs.d': false 'notes.txt': true } z: home.'notes.txt'","title":"Operators and Identifiers"},{"location":"operators-and-identifiers/#normal-identifiers","text":"Normal operators are brought into scope by declarations and can be referred to without qualification in their own block or in more nested blocks: x: { z: 99 foo: z //=> 99 bar: { y: z //=> 99 } } They can be accessed from within other blocks using the lookup operator: x: { z: 99 } y: x.z //=> 99 They can be overridden using generalised lookup: z: 99 y: { z: 100 }.\"z is {z}\" //=> \"z is 100\" They can be shadowed: z: 99 y: { z: 100 r: z //=> 100 } But beware trying to access the outer value: name: \"foo\" x: { name: name } //=> infinite recursion Accessing shadowed values is not yet easily possible unless you can refer to an enclosing block and use a lookup.","title":"Normal identifiers"},{"location":"operators-and-identifiers/#operator-identifiers","text":"Operator identifiers are more limited than normal identifiers. They are brought into scope by operator declarations and available without qualification in their own block and more nested blocks: ( l -->> r): \"{l} shoots arrow at {r}\" x: { y: 2 -->> 3 //=> \"2 shoots arrow at 3\" } ...and can be shadowed: (l !!! r): l + r y: { (l !!! r): l - r z: 100 !!! 1 //=> 99 } But: they cannot be accessed by lookup, so there is no way of forming a qualified name to access an operator they cannot be overridden by generalised lookup","title":"Operator identifiers"},{"location":"philosophy-lang/","text":"eucalypt (the language) eucalypt , the language, is unorthodox in many respects - probably more than you might realise on first acquaintance. People tend to have deep-seated and inflexible opinions about programming languages and language design and will quite possibly find something in here that they have a kneejerk reaction against. However, the design is not unprincipled and, while it is experimental in some respects, I believe it's internally consistent. Several aspects of the design and the aesthetic are driven by the primary use case, templating and generating YAML. Maybe by exploring some of the inspiration and philosophy behind the language itself, I can pre-empt some of the knee jerks. Accept crypticality for minimal intrusion eucalypt is first and foremost a tool , rather than a language. It is intended to replace generation and transformation processes on semi-structured data formats. Many or most uses of eucalypt the language should just be simple one-liner tags in YAML files, or maybe eucalypt files that are predominantly data rather than manipulation. The eucalypt language is the depth behind these one-liners that allows eucalypt to accommodate increasingly ambitious use cases without breaking the paradigm and reaching for a general purpose imperative scripting language or the lowest common denominator or text-based templating languages. The pre-eminence of one-liners and small annotations and \"logic mark-up\", means that eucalypt often favours concise and cryptic over wordy and transparent. This is a controversial approach. eucalypt logic should \"get out of the way\" of the data. Templating is attractive precisely because the generating source looks very like the result. Template tags are often short (with \"cryptic\" delimiters - {{}} , <%= %> , [| ] ...) because these are \"marking up\" the data which is the main event. At the same time, the tags are often \"noisy\" or visually disruptive to ensure they cannot be ignored. eucalypt via operator and bracket definitions, picks and chooseS from a similar palette of expressive effects to try and be a sympathetic cohabitee with its accompanying data. There are many cases where it makes sense to resist offering an incomplete understanding in favour of demanding full understanding. For example, it is spurious to say that bind(x, f) gives more understanding of what is going on than x >>= f - unless you understand the monad abstraction and the role of bind in it, you gain nothing useful from the ideas that the word bind connotes when you are trying to understand program text. eucalypt just plain ignores the notion that program text should be readable as English text . This (well motivated) idea has made a resurgence in recent years through the back door of internal DSLs and \"fluent\" Java interfaces. There is much merit in languages supple enough to allow the APIs to approach the natural means of expression of the problem domain. However, problem domains frequently have their own technical jargon and notation which suit their purpose better than natural language so it cuts both ways. Program text should be approachable by its target audience but that does not mean it should make no demands of its target audience. These stances lead directly to several slightly esoteric aspects of eucalypt that may be obnoxious to some: eucalypt tends to be operator-heavy. Operators are concise (if cryptic) and the full range of unicode is available to call upon. Using operators keeps custom logic visually out of the way of the data whilst also signposting it to attract closer attention. eucalypt lets you define your own operators and specify their precedence and associativity (which are applied at a relatively late stage in the evaluation pipeline - operator soup persists through the initial parse). There are no ternary operators. For absolute minimal intrusion, merely the act of placing elements next to each other (\"catenation\"), x f , is meaningful in eucalypt . By default this is pipeline-order function application, but blocks can be applied as functions to make common transformations, like block merge, very succinct. For even more power, eucalypt might soon let you alter the meaning of concatenation via overloaded idiot brackets 1 . ( \u00abx y\u00bb: ... ). This is inspired by the idiom brackets that can be used to express applicative styles in functional programming 2 . These may also provide an acceptable proxy for ternary and other operators too. An equivalent generalisation of eucalypt block syntax to provide a capability similar to Haskell's do notation could conceivably follow. Cohabitation of code and data Just like templates, eucalypt source (or eucalypt -tagged YAML) should be almost entirely data. The idea behind eucalypt is to adopt the basic maps-and-arrays organisation philosophy of these data formats but make the data active - allowing lambdas to live in and amongst it and operate on it and allowing the data to express dispositions towards its environment by addition of metadata that controls import, export, and execution preferences. eucalypt therefore collapses the separation of code and data to some degree. You can run eu against a mixture of YAML, JSON and eucalypt files and all the data and logic appears there together in the same namespace hierarchy. The namespace hierarchy just is the data. However, code and data aren't unified in the sense of Lisp for instance. eucalypt is not homoiconic. The relationship is more like cohabitation; code lives in amongst the data it operates on but is stripped out before export. Nevertheless eucalypt is heavily inspired by Lisp and aims for a similar fluidity through: lazy evaluation (going some way towards matching uses of Lisp macros which control evaluation order - in eucalypt, if is just a function) economical syntax to facilitate (future) manipulation of code as data Simplicity eucalypt values simplicity in the sense of fewer moving parts (and therefore, hopefully, fewer things to go wrong). It values ease of use in the sense of offering a rich and powerful toolkit. You may not think it achieves either. eucalypt values familiarity mostly in the \"shallower\" parts of the language where it only requires a couple of mental leaps for the average programmer in these areas - the (ab)use of catenation being the key one. However, eucalypt isn't ashamed of its dusty corners. Dusty corners are areas where novices and experts alike can get trapped and lose time but they're also rich seams for experimentation, innovation and discovery. If you have to venture too far off-piste to find what you need, we'll find a way to bring it onto the nursery slopes but we won't close off the mountain. Footnotes Inspired by idiom brackets . If I didn't call them that, someone else would. \u21a9 Applicative Programming with Effects, Conor McBride and Ross Paterson. (2008) http://www.staff.city.ac.uk/~ross/papers/Applicative.html \u21a9","title":"Philosophy"},{"location":"philosophy-lang/#eucalypt-the-language","text":"eucalypt , the language, is unorthodox in many respects - probably more than you might realise on first acquaintance. People tend to have deep-seated and inflexible opinions about programming languages and language design and will quite possibly find something in here that they have a kneejerk reaction against. However, the design is not unprincipled and, while it is experimental in some respects, I believe it's internally consistent. Several aspects of the design and the aesthetic are driven by the primary use case, templating and generating YAML. Maybe by exploring some of the inspiration and philosophy behind the language itself, I can pre-empt some of the knee jerks.","title":"eucalypt (the language)"},{"location":"philosophy-lang/#accept-crypticality-for-minimal-intrusion","text":"eucalypt is first and foremost a tool , rather than a language. It is intended to replace generation and transformation processes on semi-structured data formats. Many or most uses of eucalypt the language should just be simple one-liner tags in YAML files, or maybe eucalypt files that are predominantly data rather than manipulation. The eucalypt language is the depth behind these one-liners that allows eucalypt to accommodate increasingly ambitious use cases without breaking the paradigm and reaching for a general purpose imperative scripting language or the lowest common denominator or text-based templating languages. The pre-eminence of one-liners and small annotations and \"logic mark-up\", means that eucalypt often favours concise and cryptic over wordy and transparent. This is a controversial approach. eucalypt logic should \"get out of the way\" of the data. Templating is attractive precisely because the generating source looks very like the result. Template tags are often short (with \"cryptic\" delimiters - {{}} , <%= %> , [| ] ...) because these are \"marking up\" the data which is the main event. At the same time, the tags are often \"noisy\" or visually disruptive to ensure they cannot be ignored. eucalypt via operator and bracket definitions, picks and chooseS from a similar palette of expressive effects to try and be a sympathetic cohabitee with its accompanying data. There are many cases where it makes sense to resist offering an incomplete understanding in favour of demanding full understanding. For example, it is spurious to say that bind(x, f) gives more understanding of what is going on than x >>= f - unless you understand the monad abstraction and the role of bind in it, you gain nothing useful from the ideas that the word bind connotes when you are trying to understand program text. eucalypt just plain ignores the notion that program text should be readable as English text . This (well motivated) idea has made a resurgence in recent years through the back door of internal DSLs and \"fluent\" Java interfaces. There is much merit in languages supple enough to allow the APIs to approach the natural means of expression of the problem domain. However, problem domains frequently have their own technical jargon and notation which suit their purpose better than natural language so it cuts both ways. Program text should be approachable by its target audience but that does not mean it should make no demands of its target audience. These stances lead directly to several slightly esoteric aspects of eucalypt that may be obnoxious to some: eucalypt tends to be operator-heavy. Operators are concise (if cryptic) and the full range of unicode is available to call upon. Using operators keeps custom logic visually out of the way of the data whilst also signposting it to attract closer attention. eucalypt lets you define your own operators and specify their precedence and associativity (which are applied at a relatively late stage in the evaluation pipeline - operator soup persists through the initial parse). There are no ternary operators. For absolute minimal intrusion, merely the act of placing elements next to each other (\"catenation\"), x f , is meaningful in eucalypt . By default this is pipeline-order function application, but blocks can be applied as functions to make common transformations, like block merge, very succinct. For even more power, eucalypt might soon let you alter the meaning of concatenation via overloaded idiot brackets 1 . ( \u00abx y\u00bb: ... ). This is inspired by the idiom brackets that can be used to express applicative styles in functional programming 2 . These may also provide an acceptable proxy for ternary and other operators too. An equivalent generalisation of eucalypt block syntax to provide a capability similar to Haskell's do notation could conceivably follow.","title":"Accept crypticality for minimal intrusion"},{"location":"philosophy-lang/#cohabitation-of-code-and-data","text":"Just like templates, eucalypt source (or eucalypt -tagged YAML) should be almost entirely data. The idea behind eucalypt is to adopt the basic maps-and-arrays organisation philosophy of these data formats but make the data active - allowing lambdas to live in and amongst it and operate on it and allowing the data to express dispositions towards its environment by addition of metadata that controls import, export, and execution preferences. eucalypt therefore collapses the separation of code and data to some degree. You can run eu against a mixture of YAML, JSON and eucalypt files and all the data and logic appears there together in the same namespace hierarchy. The namespace hierarchy just is the data. However, code and data aren't unified in the sense of Lisp for instance. eucalypt is not homoiconic. The relationship is more like cohabitation; code lives in amongst the data it operates on but is stripped out before export. Nevertheless eucalypt is heavily inspired by Lisp and aims for a similar fluidity through: lazy evaluation (going some way towards matching uses of Lisp macros which control evaluation order - in eucalypt, if is just a function) economical syntax to facilitate (future) manipulation of code as data","title":"Cohabitation of code and data"},{"location":"philosophy-lang/#simplicity","text":"eucalypt values simplicity in the sense of fewer moving parts (and therefore, hopefully, fewer things to go wrong). It values ease of use in the sense of offering a rich and powerful toolkit. You may not think it achieves either. eucalypt values familiarity mostly in the \"shallower\" parts of the language where it only requires a couple of mental leaps for the average programmer in these areas - the (ab)use of catenation being the key one. However, eucalypt isn't ashamed of its dusty corners. Dusty corners are areas where novices and experts alike can get trapped and lose time but they're also rich seams for experimentation, innovation and discovery. If you have to venture too far off-piste to find what you need, we'll find a way to bring it onto the nursery slopes but we won't close off the mountain.","title":"Simplicity"},{"location":"philosophy-lang/#footnotes","text":"Inspired by idiom brackets . If I didn't call them that, someone else would. \u21a9 Applicative Programming with Effects, Conor McBride and Ross Paterson. (2008) http://www.staff.city.ac.uk/~ross/papers/Applicative.html \u21a9","title":"Footnotes"},{"location":"syntax/","text":"The role of Eucalypt's syntax Eucalypt has a native syntax which emphasises the mappings-and-lists nature of its underlying data model but adds enhancements for functions and expressions. Eucalypt is written in .eu files. While eu happily processes YAML inputs with embedded expressions, many features are not yet available in the YAML embedding and the embedded expressions are themselves in Eucalypt syntax, so it is necessary to have an overview of how the syntax works to do anything interesting with Eucalypt. A few aspects are unorthodox and experimental. Overview Eucalypt syntax comes about by the an overlapping of two sub-languages. the block DSL is how you write blocks and their declarations the expression DSL is how you write expressions They are entwined in a fairly typical way: block literals (from the block DSL ) can be used in expressions (from the expression DSL ) and expressions (from the expression DSL ) appear in declarations (from the block DSL ). Comments can be interspersed throughout. Eucalypt only has line level comments. foo: bar # Line comments start with '#' and run till the end of the line Note If you feel you need a block comment, you can use an actual block or a string property within a block and mark it with annotation metadata :suppress to ensure it doesn't appear in output. Eucalypt has two types of names: normal names, which are largely alphanumeric (e.g. f , blah , some-thing! , \u0975 ) and are used to name properties and functions operator names, which are largely symbolic (e.g. &&& , \u2227 , -+-| , \u229a ) and are used to name operators See Operators and Identifiers for more. The block DSL A block is surrounded by curly braces: ... { ... } ...and contains declarations... ... { a: 1 b: 2 c: 3 } ...which may themselves have blocks as values... ... { foo: { bar: { baz: \"hello world\" } } } The top-level block in a file (a unit ) does not have braces: a: 1 b: 2 c: 3 So far all these declarations have been property declarations which contains a name and an expression, separated by a colon. Commas are entirely optional for delimiting declarations. Line endings are not significant. The following is a top-level block of three property declarations . a: 1 b: 2 c: 3 There are other types of declarations. By specifying a parameter list, you get a function declaration : # A function declaration f(x, y): x + y two: f(1, 1) ...and using some brackets and suitable names, you can define operators too, either binary: # A binary operator declaration (x ^|^ y): \"{x} v {y}\" ...or prefix or postfix unary operators: # A prefix operator declaration (\u00ac x): not(x) # A postfix operator declaration (x ******): \"maybe {x}\" Eucalypt should handle unicode gracefully and any unicode characters in the symbol or punctuation classes are fine for operators. To control the precedence and associativity of user defined operators, you need metadata annotations. declaration annotations allow us to specify arbitrary metadata against declarations. These can be used for documentation and similar. To attach an annotation to a declaration, squeeze it between a leading backtick and the declaration itself: ` { doc: \"This is a\"} a: 1 ` { doc: \"This is b\"} b: 2 Some metadata activate special handling, such as the associates and precedence keys you can put on operator declarations: ` { doc: \"`(f \u2218 g)` - return composition of `f` and `g`\" associates: :right precedence: 88 } (f \u2218 g): compose(f,g) Look out for other uses like :target , :suppress , :main . Finally, you can specify metadata at a unit level. If the first item in a unit is an expression, rather than a declaration, it is treated as metadata that is applied to the whole unit. { :doc \"This is just an example unit\" } a: 1 b: 2 c: 3 The expression DSL Everything that can appear to the right of the colon in a declaration is an expression and defined by the expression DSL. Primitives First there are primitives. ...numbers... 123 -123 123.333 ...double quoted strings... \"a string\" ... symbols , prefixed by a colon... :key ...which are currently very like strings, but used in circumstances where their internal structure is generally not significant (i.e. keys in a block's internal representation). Finally, booleans ( true and false ) are pre-defined constants. As is ( null ) which is a value which renders as YAML or JSON's version of null but is not used by Eucalypt itself. Block literals Block literals (in braces, as defined in the block DSL ) are expressions and can be the values of declarations or passed as function arguments or operands in any of the contexts below: foo: { a: 1 b: 2 c: 3} List literals List literals are enclosed in square brackets and contain a comma separated sequence of expressions: list: [1, 2, :a, \"boo\"] Names Then there are names , which refer to the surrounding context. They might refer to properties: x: 22 y: x ...or functions : add-one(x): 1 + x three: add-one(2) ...or operators : (x &&& y): [x, x, x, y] z: \"da\" &&& \"dum\" Calling functions Functions can be applied by suffixing a argument list in parens, with no intervening whitespace : f(x, y): x + y result: f(2, 2) # no whitespace In the special case of applying a single argument, \"catenation\" can be used: add-one(x): 1 + x result: 2 add-one ...which allows succinct expressions of pipelines of operations. In addition, functions are curried so can be partially applied: add(x, y): x + y incremement: add(1) result: 2 increment ...and placeholder underscores (or expression anaphora ) can be used to define simple functions without the song and dance of a function declaration: f: if(tuesday?, (_ * 32 / 12), (99 / _)) result: f(3) In fact, in many cases the underscores can be omitted, leading to a construct very similar to Haskell's sections only even brackets aren't necessary. Note Eucalypt uses its knowledge of the fixity and associativity of each operator to find \"gaps\" and fills them with the unwritten underscores. This is great for simple cases but worth avoiding for complicated expressions. increment: + 1 result: 2 increment (126 /) Both styles of function application together with partial application and sectioning can all be applied together: result: [1, 2, 3] map(+1) filter(odd?) //=> [3] ( //=> is an assertion operator which causes a panic if the left and right hand expressions aren't found to be equal at run time, but returns that value if they are. Note There are no explicit lambda expressions in Eucalypt right now. For simple cases, expression or string anaphora should do the job. For more involved cases, you should use a named function declaration. See Anaphora and Lambdas for more.","title":"Syntax"},{"location":"syntax/#the-role-of-eucalypts-syntax","text":"Eucalypt has a native syntax which emphasises the mappings-and-lists nature of its underlying data model but adds enhancements for functions and expressions. Eucalypt is written in .eu files. While eu happily processes YAML inputs with embedded expressions, many features are not yet available in the YAML embedding and the embedded expressions are themselves in Eucalypt syntax, so it is necessary to have an overview of how the syntax works to do anything interesting with Eucalypt. A few aspects are unorthodox and experimental.","title":"The role of Eucalypt's syntax"},{"location":"syntax/#overview","text":"Eucalypt syntax comes about by the an overlapping of two sub-languages. the block DSL is how you write blocks and their declarations the expression DSL is how you write expressions They are entwined in a fairly typical way: block literals (from the block DSL ) can be used in expressions (from the expression DSL ) and expressions (from the expression DSL ) appear in declarations (from the block DSL ). Comments can be interspersed throughout. Eucalypt only has line level comments. foo: bar # Line comments start with '#' and run till the end of the line Note If you feel you need a block comment, you can use an actual block or a string property within a block and mark it with annotation metadata :suppress to ensure it doesn't appear in output. Eucalypt has two types of names: normal names, which are largely alphanumeric (e.g. f , blah , some-thing! , \u0975 ) and are used to name properties and functions operator names, which are largely symbolic (e.g. &&& , \u2227 , -+-| , \u229a ) and are used to name operators See Operators and Identifiers for more.","title":"Overview"},{"location":"syntax/#the-block-dsl","text":"A block is surrounded by curly braces: ... { ... } ...and contains declarations... ... { a: 1 b: 2 c: 3 } ...which may themselves have blocks as values... ... { foo: { bar: { baz: \"hello world\" } } } The top-level block in a file (a unit ) does not have braces: a: 1 b: 2 c: 3 So far all these declarations have been property declarations which contains a name and an expression, separated by a colon. Commas are entirely optional for delimiting declarations. Line endings are not significant. The following is a top-level block of three property declarations . a: 1 b: 2 c: 3 There are other types of declarations. By specifying a parameter list, you get a function declaration : # A function declaration f(x, y): x + y two: f(1, 1) ...and using some brackets and suitable names, you can define operators too, either binary: # A binary operator declaration (x ^|^ y): \"{x} v {y}\" ...or prefix or postfix unary operators: # A prefix operator declaration (\u00ac x): not(x) # A postfix operator declaration (x ******): \"maybe {x}\" Eucalypt should handle unicode gracefully and any unicode characters in the symbol or punctuation classes are fine for operators. To control the precedence and associativity of user defined operators, you need metadata annotations. declaration annotations allow us to specify arbitrary metadata against declarations. These can be used for documentation and similar. To attach an annotation to a declaration, squeeze it between a leading backtick and the declaration itself: ` { doc: \"This is a\"} a: 1 ` { doc: \"This is b\"} b: 2 Some metadata activate special handling, such as the associates and precedence keys you can put on operator declarations: ` { doc: \"`(f \u2218 g)` - return composition of `f` and `g`\" associates: :right precedence: 88 } (f \u2218 g): compose(f,g) Look out for other uses like :target , :suppress , :main . Finally, you can specify metadata at a unit level. If the first item in a unit is an expression, rather than a declaration, it is treated as metadata that is applied to the whole unit. { :doc \"This is just an example unit\" } a: 1 b: 2 c: 3","title":"The block DSL"},{"location":"syntax/#the-expression-dsl","text":"Everything that can appear to the right of the colon in a declaration is an expression and defined by the expression DSL.","title":"The expression DSL"},{"location":"syntax/#primitives","text":"First there are primitives. ...numbers... 123 -123 123.333 ...double quoted strings... \"a string\" ... symbols , prefixed by a colon... :key ...which are currently very like strings, but used in circumstances where their internal structure is generally not significant (i.e. keys in a block's internal representation). Finally, booleans ( true and false ) are pre-defined constants. As is ( null ) which is a value which renders as YAML or JSON's version of null but is not used by Eucalypt itself.","title":"Primitives"},{"location":"syntax/#block-literals","text":"Block literals (in braces, as defined in the block DSL ) are expressions and can be the values of declarations or passed as function arguments or operands in any of the contexts below: foo: { a: 1 b: 2 c: 3}","title":"Block literals"},{"location":"syntax/#list-literals","text":"List literals are enclosed in square brackets and contain a comma separated sequence of expressions: list: [1, 2, :a, \"boo\"]","title":"List literals"},{"location":"syntax/#names","text":"Then there are names , which refer to the surrounding context. They might refer to properties: x: 22 y: x ...or functions : add-one(x): 1 + x three: add-one(2) ...or operators : (x &&& y): [x, x, x, y] z: \"da\" &&& \"dum\"","title":"Names"},{"location":"syntax/#calling-functions","text":"Functions can be applied by suffixing a argument list in parens, with no intervening whitespace : f(x, y): x + y result: f(2, 2) # no whitespace In the special case of applying a single argument, \"catenation\" can be used: add-one(x): 1 + x result: 2 add-one ...which allows succinct expressions of pipelines of operations. In addition, functions are curried so can be partially applied: add(x, y): x + y incremement: add(1) result: 2 increment ...and placeholder underscores (or expression anaphora ) can be used to define simple functions without the song and dance of a function declaration: f: if(tuesday?, (_ * 32 / 12), (99 / _)) result: f(3) In fact, in many cases the underscores can be omitted, leading to a construct very similar to Haskell's sections only even brackets aren't necessary. Note Eucalypt uses its knowledge of the fixity and associativity of each operator to find \"gaps\" and fills them with the unwritten underscores. This is great for simple cases but worth avoiding for complicated expressions. increment: + 1 result: 2 increment (126 /) Both styles of function application together with partial application and sectioning can all be applied together: result: [1, 2, 3] map(+1) filter(odd?) //=> [3] ( //=> is an assertion operator which causes a panic if the left and right hand expressions aren't found to be equal at run time, but returns that value if they are. Note There are no explicit lambda expressions in Eucalypt right now. For simple cases, expression or string anaphora should do the job. For more involved cases, you should use a named function declaration. See Anaphora and Lambdas for more.","title":"Calling functions"},{"location":"yaml-embedding/","text":"YAML Embedding Eucalypt can be embedded in YAML files via the following tags: eu eu::suppress eu::fn The YAML embedding is not as capable as the native Eucalypt syntax but it is rich enough to be used for many YAML templating use cases, particularly when combined with the ability to specify several inputs on the command line. Evaluating eucalypt expressions As you would expect, YAML mappings correspond to Eucalypt blocks and bind names just as Eucalypt blocks do and YAML sequences correspond to Eucalypt lists. YAML allow a wide variety of forms of expressing these (block styles and flow styles), to the extent that JSON is valid YAML. Eucalypt expressions can be evaluated using the !eu tag and have access to all the names defined in the YAML unit and any others brought into scope by specifying inputs on the command line. values: x: world y: hello result: !eu \"{values.y} {values.x}!\" ...will render as: values: x: world y: hello result: Hello World! Suppressing rendering Items can be hidden using the eu::suppress tag. This is equivalent to :suppress metadata in the eucalypt syntax. values: !eu::suppress x: world y: hello result: !eu \"{values.y} {values.x}!\" ...will render as: result: Hello World! Defining functions Functions can be defined using eu::fn and supplying an argument list: values: !eu::suppress x: world y: hello greet: !eu::fn (h, w) \"{h} {w}!\" result: !eu values.greet(values.y, values.x) ...will render as: result: Hello World! The escape hatch Larger chunks of eucalypt syntax can be embedded using YAML's support for larger chunks of text, combined with !eu . Using this workaround you can access capabilities of eucalypt that are not yet available in the YAML embedding. (Although operators cannot be made available in YAML blocks because of the way that operator names are bound - see Operators and Identifiers . block: !eu | { x: 99 (l ^^^ r): \"{l} <_> {r}\" f(n): n ^^^ x } result: block.f(99)","title":"YAML Embedding"},{"location":"yaml-embedding/#yaml-embedding","text":"Eucalypt can be embedded in YAML files via the following tags: eu eu::suppress eu::fn The YAML embedding is not as capable as the native Eucalypt syntax but it is rich enough to be used for many YAML templating use cases, particularly when combined with the ability to specify several inputs on the command line.","title":"YAML Embedding"},{"location":"yaml-embedding/#evaluating-eucalypt-expressions","text":"As you would expect, YAML mappings correspond to Eucalypt blocks and bind names just as Eucalypt blocks do and YAML sequences correspond to Eucalypt lists. YAML allow a wide variety of forms of expressing these (block styles and flow styles), to the extent that JSON is valid YAML. Eucalypt expressions can be evaluated using the !eu tag and have access to all the names defined in the YAML unit and any others brought into scope by specifying inputs on the command line. values: x: world y: hello result: !eu \"{values.y} {values.x}!\" ...will render as: values: x: world y: hello result: Hello World!","title":"Evaluating eucalypt expressions"},{"location":"yaml-embedding/#suppressing-rendering","text":"Items can be hidden using the eu::suppress tag. This is equivalent to :suppress metadata in the eucalypt syntax. values: !eu::suppress x: world y: hello result: !eu \"{values.y} {values.x}!\" ...will render as: result: Hello World!","title":"Suppressing rendering"},{"location":"yaml-embedding/#defining-functions","text":"Functions can be defined using eu::fn and supplying an argument list: values: !eu::suppress x: world y: hello greet: !eu::fn (h, w) \"{h} {w}!\" result: !eu values.greet(values.y, values.x) ...will render as: result: Hello World!","title":"Defining functions"},{"location":"yaml-embedding/#the-escape-hatch","text":"Larger chunks of eucalypt syntax can be embedded using YAML's support for larger chunks of text, combined with !eu . Using this workaround you can access capabilities of eucalypt that are not yet available in the YAML embedding. (Although operators cannot be made available in YAML blocks because of the way that operator names are bound - see Operators and Identifiers . block: !eu | { x: 99 (l ^^^ r): \"{l} <_> {r}\" f(n): n ^^^ x } result: block.f(99)","title":"The escape hatch"}]}