<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Syntax - eucalypt</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Syntax";
    var mkdocs_page_input_path = "syntax.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-42926869-3', 'curvelogic.co.uk');
      ga('send', 'pageview');
  </script>
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> eucalypt</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../getting-started/">Getting Started</a>
                    </li>
                </ul>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Syntax</a>
    <ul class="current">
    </ul>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../command-line/">Command Line</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../imports/">Imports</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../operators-and-identifiers/">Operators and Identifiers</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../yaml-embedding/">YAML Embedding</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../anaphora-and-lambdas/">Anaphora and Lambdas</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../implementation/">Implementation</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../philosophy-lang/">Philosophy</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">eucalypt</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Syntax</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/curvelogic/eucalypt/edit/master/docs/syntax.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="the-role-of-eucalypts-syntax">The role of Eucalypt's syntax</h1>
<p>Eucalypt has a native syntax which emphasises the mappings-and-lists
nature of its underlying data model but adds enhancements for
functions and expressions. Eucalypt is written in <code>.eu</code> files.</p>
<p>While <code>eu</code> happily processes YAML inputs with embedded expressions,
many features are not yet available in the YAML embedding and the
embedded expressions are themselves in Eucalypt syntax, so it is
necessary to have an overview of how the syntax works to do anything
interesting with Eucalypt.</p>
<p>A few aspects are unorthodox and experimental.</p>
<h1 id="overview">Overview</h1>
<p>Eucalypt syntax comes about by the an overlapping of two
sub-languages.</p>
<ul>
<li>the <em>block DSL</em> is how you write blocks and their declarations</li>
<li>the <em>expression DSL</em> is how you write expressions</li>
</ul>
<p>They are entwined in a fairly typical way: block literals (from the
<em>block DSL</em>) can be used in expressions (from the <em>expression DSL</em>)
and expressions (from the <em>expression DSL</em>) appear in declarations
(from the <em>block DSL</em>).</p>
<p>Comments can be interspersed throughout. Eucalypt only has line level
comments.</p>
<pre><code class="language-eu">foo: bar # Line comments start with '#' and run till the end of the line
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you feel you need a block comment, you can use an actual block or a
string property within a block and mark it with annotation metadata
<code>:suppress</code> to ensure it doesn't appear in output.</p>
</div>
<p>Eucalypt has two types of names:</p>
<ul>
<li>normal names, which are largely alphanumeric (e.g. <code>f</code>, <code>blah</code>,
  <code>some-thing!</code>, <code>ॵ</code>) and are used to name properties and functions</li>
<li>operator names, which are largely symbolic (e.g. <code>&amp;&amp;&amp;</code>, <code>∧</code>, <code>-+-|</code>,
  <code>⊚</code>) and are used to name operators</li>
</ul>
<p>See <a href="../operators-and-identifiers/">Operators and Identifiers</a> for more.</p>
<h2 id="the-block-dsl">The block DSL</h2>
<p>A <strong>block</strong> is surrounded by curly braces:</p>
<pre><code class="language-eu">... { ... }
</code></pre>
<p>...and contains declarations...</p>
<pre><code class="language-eu">... {
  a: 1
  b: 2
  c: 3
}
</code></pre>
<p>...which may themselves have blocks as values...</p>
<pre><code class="language-eu">... {
  foo: {
    bar: {
      baz: &quot;hello world&quot;
    }
  }
}
</code></pre>
<p>The top-level block in a file (a <strong>unit</strong>) does not have braces:</p>
<pre><code class="language-eu">a: 1
b: 2
c: 3
</code></pre>
<p>So far all these declarations have been <strong>property declarations</strong> which
contains a name and an expression, separated by a colon.</p>
<p>Commas are entirely optional for delimiting declarations. Line endings
are not significant. The following is a top-level block of three
<strong>property declarations</strong>.</p>
<pre><code class="language-eu">a: 1 b: 2 c: 3
</code></pre>
<p>There are other types of declarations. By specifying a parameter list,
you get a <strong>function declaration</strong>:</p>
<pre><code class="language-eu"># A function declaration
f(x, y): x + y

two: f(1, 1)
</code></pre>
<p>...and using some brackets and suitable names, you can define
operators too, either binary:</p>
<pre><code class="language-eu"># A binary operator declaration
(x ^|^ y): &quot;{x} v {y}&quot;
</code></pre>
<p>...or prefix or postfix unary operators:</p>
<pre><code class="language-eu"># A prefix operator declaration
(¬ x): not(x)

# A postfix operator declaration
(x ******): &quot;maybe {x}&quot;
</code></pre>
<p>Eucalypt should handle unicode gracefully and any unicode characters
in the symbol or punctuation classes are fine for operators.</p>
<p>To control the precedence and associativity of user defined operators,
you need metadata annotations.</p>
<p><strong>declaration annotations</strong> allow us to specify arbitrary metadata
against declarations. These can be used for documentation and similar.</p>
<p>To attach an annotation to a declaration, squeeze it between a leading
backtick and the declaration itself:</p>
<pre><code class="language-eu">` { doc: &quot;This is a&quot;}
a: 1

` { doc: &quot;This is b&quot;}
b: 2
</code></pre>
<p>Some metadata activate special handling, such as the <code>associates</code> and
<code>precedence</code> keys you can put on operator declarations:</p>
<pre><code class="language-eu">` { doc: &quot;`(f ∘ g)` - return composition of `f` and `g`&quot;
    associates: :right
    precedence: 88 }
(f ∘ g): compose(f,g)
</code></pre>
<p>Look out for other uses like <code>:target</code>, <code>:suppress</code>, <code>:main</code>.</p>
<p>Finally, you can specify metadata at a unit level. If the first item
in a unit is an expression, rather than a declaration, it is treated
as metadata that is applied to the whole unit.</p>
<pre><code class="language-eu">{ :doc &quot;This is just an example unit&quot; }
a: 1 b: 2 c: 3
</code></pre>
<h2 id="the-expression-dsl">The expression DSL</h2>
<p>Everything that can appear to the right of the colon in a declaration
is an expression and defined by the expression DSL.</p>
<h3 id="primitives">Primitives</h3>
<p>First there are primitives.</p>
<p>...numbers...</p>
<pre><code class="language-eu">123
</code></pre>
<pre><code class="language-eu">-123
</code></pre>
<pre><code class="language-eu">123.333
</code></pre>
<p>...double quoted strings...</p>
<pre><code class="language-eu">&quot;a string&quot;
</code></pre>
<p>...<strong>symbols</strong>, prefixed by a colon...</p>
<pre><code class="language-eu">:key
</code></pre>
<p>...which are currently very like strings, but used in circumstances
where their internal structure is generally not significant (i.e. keys
in a block's internal representation).</p>
<p>Finally, booleans (<code>true</code> and <code>false</code>) are pre-defined constants. As
is (<code>null</code>) which is a value which renders as YAML or JSON's version
of null but is not used by Eucalypt itself.</p>
<h3 id="block-literals">Block literals</h3>
<p>Block literals (in braces, as defined in the <em>block DSL</em>) are
expressions and can be the values of declarations or passed as
function arguments or operands in any of the contexts below:</p>
<pre><code class="language-eu">foo: { a: 1 b: 2 c: 3}
</code></pre>
<h3 id="list-literals">List literals</h3>
<p>List literals are enclosed in square brackets and contain a comma
separated sequence of expressions:</p>
<pre><code class="language-eu">list: [1, 2, :a, &quot;boo&quot;]
</code></pre>
<h3 id="names">Names</h3>
<p>Then there are <strong>names</strong>, which refer to the surrounding context. They
might refer to properties:</p>
<pre><code class="language-eu">x: 22
y: x
</code></pre>
<p>...or <em>functions</em>:</p>
<pre><code class="language-eu">add-one(x): 1 + x
three: add-one(2)
</code></pre>
<p>...or <em>operators</em>:</p>
<pre><code class="language-eu">(x &amp;&amp;&amp; y): [x, x, x, y]
z: &quot;da&quot; &amp;&amp;&amp; &quot;dum&quot;
</code></pre>
<h3 id="calling-functions">Calling functions</h3>
<p>Functions can be applied by suffixing a argument list in parens, with
<em>no intervening whitespace</em>:</p>
<pre><code class="language-eu">f(x, y): x + y
result: f(2, 2) # no whitespace
</code></pre>
<p>In the special case of applying a single argument, <em>"catenation"</em> can
be used:</p>
<pre><code class="language-eu">add-one(x): 1 + x
result: 2 add-one
</code></pre>
<p>...which allows succinct expressions of pipelines of operations.</p>
<p>In addition, functions are curried so can be partially applied:</p>
<pre><code class="language-eu">add(x, y): x + y
incremement: add(1)
result: 2 increment
</code></pre>
<p>...and placeholder underscores (or <em>expression anaphora</em>) can be used
to define simple functions without the song and dance of a function
declaration:</p>
<pre><code class="language-eu">f: if(tuesday?, (_ * 32 / 12), (99 / _))
result: f(3)
</code></pre>
<p>In fact, in many cases the underscores can be omitted, leading to a
construct very similar to Haskell's <em>sections</em> only even brackets
aren't necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Eucalypt uses its knowledge of the fixity and associativity of
each operator to find "gaps" and fills them with the unwritten
underscores. This is great for simple cases but worth avoiding for
complicated expressions.</p>
</div>
<pre><code class="language-eu">increment: + 1
result: 2 increment (126 /)
</code></pre>
<p>Both styles of function application together with partial application
and sectioning can all be applied together:</p>
<pre><code class="language-eu">result: [1, 2, 3] map(+1) filter(odd?) //=&gt; [3]
</code></pre>
<p>(<code>//=&gt;</code> is an assertion operator which causes a panic if the left and
right hand expressions aren't found to be equal at run time, but
returns that value if they are.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are no explicit lambda expressions in Eucalypt right now.
For simple cases, expression or string anaphora should do the job.
For more involved cases, you should use a named function declaration.
See <a href="../anaphora-and-lambdas/">Anaphora and Lambdas</a> for more.</p>
</div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../command-line/" class="btn btn-neutral float-right" title="Command Line">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../getting-started/" class="btn btn-neutral" title="Getting Started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright (C) 2018-2021 Greg Hawkins</p>
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/curvelogic/eucalypt/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../getting-started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../command-line/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
