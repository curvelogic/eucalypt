# -*- mode: conf -*-

# Eucalypt standard prelude

##
## Prelude versioning and run metadata
##
eu: {
  ` "Metadata about this version of the standard prelude"
  prelude: {
    version: "0.1.0"
  }

  ` "Metadata about this version of the eucalypt executable"
  build: {
    version: __build.version
    commit: __build.eu-build.commit
    url: __build.eu-build.url
  }
}

` "IO related declarations"
io: {
  ` "Read access to environent variables at time of launch"
  env: __io.ENV

  epoch-time: __io.EPOCHTIME
}


##
## Error / debug support
##

` "`panic(s)` - raise runtime error with message string `s`."
panic: __PANIC

` "`assert(c, s, v)` - if `c` is true then value `v` otherwise error with message `s`."
assert(c, s, v): if(c, v, panic(s))

##
## Essentials
##

` "A null value. To export as `null` in JSON or ~ in YAML."
null: __NULL

` "`true` - constant logical true"
true: __TRUE

` "`false` - constant logical false"
false: __FALSE

` "`cat(a, b)` - explicit catenation, cat(a, b) = a b. Can be useful in folds etc."
cat: __CAT

` "`if(c, t, f)` - if `c` is `true`, return `t` else `f`."
if: __IF

` "`then(t, f, c)` - for pipeline if: - `x? then(t, f)``"
then(t, f, c): if(c, t, f)

##
## List basics
##

` "`cons(h, t)` - construct new list by prepending item `h` to list `t`."
cons: __CONS

` "`head(xs)` - return the head item of list `xs`, panic if empty."
head: __HEAD

` "`head-or(xs, d)` - return the head item of list `xs` or default `d` if empty."
head-or(xs, d): xs nil? then(xs head, d)

` "`tail(l)` - return list `l` without the head item. [] causes error."
tail: __TAIL

` "`nil` - identical to `[]`, the empty list."
nil: []

` "`first(xs)` - return first item of list `xs` - error if the list is empty."
first: head

` "`second(xs)` - return second item of list - error if there is none."
second(xs): xs tail head

##
## Blocks / merge
##

` "`sym(s)` - create symbol with name given by string `s`."
sym: __SYM

` "`merge(b1, b2)` - shallow merge block `b2` on top of `b1`."
merge: __MERGE

` "`deep-merge(b1, b2)` - deep merge block `b2` on top of `b1`, merges nested blocks but not lists."
deep-merge: __DEEPMERGE

` { doc: "`l << r` - deep merge block `r` on top of `l`, merging nested blocks, not lists."
    export: :suppress
    associates: :left
    precedence: :append }
(l << r): __DEEPMERGE(l, r)

` "`elements(b)` - expose list of elements of block `b`."
elements: __ELEMENTS

` "`block(kvs)` - (re)construct block from list `kvs` of elements."
block: __BLOCK

` "`has(s, b)` - true if and only if block `b` has key (symbol) `s`."
has(s, b): b map-values(const(true)) lookup-or(s, false)

` "`lookup(s, b)` - look up symbol `s` in block `b`, error if not found."
lookup(s, b): __LOOKUP(s, b)

` "`lookup-in(b, s)` - look up symbol `s` in block `b`, error if not found."
lookup-in(b, s): __LOOKUP(s, b)

` "`lookup-or(s, d, b)` - look up symbol `s` in block `b`, default `d` if not found."
lookup-or(s, d, b): __LOOKUPOR(s, d, b)

` "`lookup-or-in(b, s, d)` - look up symbol `s` in block `b`, default `d` if not found."
lookup-or-in(b, s, d): lookup-or(s, d, b)

` "`lookup-alts(syms, d)` - look up symbols `syms` in turn in block `b` until a value is found, default `d` if none."
lookup-alts(syms, d, b): foldr(lookup-or-in(b), d, syms)

##
## Boolean
##

` "`not(b) - toggle boolean."
not: __NOT

` { doc: "`!x` - not x, toggle boolean."
    precedence: :bool-unary }
(! b): b not

` { doc: "`¬x` - not x, toggle boolean."
    precedence: :bool-unary }
(¬ b): b not

` { doc: "`l && r` - true if and only if `l` and `r` are true."
    export: :suppress
    associates: :left
    precedence: :bool-prod }
(l && r): __AND(l, r)

` "`and(l, r)` - true if and only if `l` and `r` are true."
and: __AND

` { doc: "`l ∧ r` - true if and only if `l` and `r`"
    export: :suppress
    associates: :left
    precedence: :bool-prod }
(l ∧ r): l && r

` "`or(l, r)` - true if and only if `l` or `r` is true."
or: __OR

` { doc: "`l || r` - true if and only if `l` or `r`"
    export: :suppress
    associates: :left
    precedence: :bool-sum }
(l || r): __OR(l, r)

` { doc: "`l ∨ r` - true if and only if `l` or `r`"
    export: :suppress
    associates: :left
    precedence: :bool-sum }
(l ∨ r): l || r

##
## Polymorphic equality, NB. while rendering disregards lambdas,
## equality does not, so values that appear equal may differ in the
## presence of lambdas.
##

` { doc: "`l = r` - `true` if and only if value `l` equals value `r`."
    export: :suppress
    associates: :left
    precedence: :eq }
(l = r): __EQ(l, r)

` { doc: "`l != r` - `true` if and only if value `l` is not equal to value `r`."
    export: :suppress
    associates: :left
    precedence: :eq }
(l != r): not(__EQ(l, r))

##
## Arithmetic
##

` { doc: "`l + r` - adds `l` and `r`; both must be numbers."
    export: :suppress
    associates: :left
    precedence: :sum }
(l + r): __ADD(l, r)

` { doc: "`l - r` - subtracts `r` from `l`; both must be numbers."
    export: :suppress
    associates: :left
    precedence: :sum }
(l - r): __SUB(l, r)

` { doc: "`l * r` - multiplies `l` and `r`; both must be numbers."
    export: :suppress
    associates: :left
    precedence: :prod }
(l * r): __MUL(l, r)

` { doc: "`l / r` - divides `l` by `r`; both must be numbers; error `r` is zero."
    export: :suppress
    associates: :left
    precedence: :prod }
(l / r): __DIV(l, r)

` { doc: "`l < r` - `true` if and only if number `l` is less than number `r`."
    export: :suppress
    associates: :left
    precedence: :cmp }
(l < r): __LT(l, r)

` { doc: "`l > r` - `true` if and only if number `l` is greater than number `r`."
    export: :suppress
    associates: :left
    precedence: :cmp }
(l > r): __GT(l, r)

` { doc: "`l <= r` - `true` if and only if number `l` is less than or equal to number `r`."
    export: :suppress
    associates: :left
    precedence: :cmp }
(l <= r): __LTE(l, r)

` { doc: "`l >= r` - `true` if and only if number `l` is greater than or equal to number `r`."
    export: :suppress
    associates: :left
    precedence: :cmp }
(l >= r): __GTE(l, r)

` "`inc(x)` - increment number `x` by 1."
inc: _ + 1

` "`dec(x)` - decrement number `x` by 1."
dec: _ - 1

` "`zero?(n)` - return true if and only if number `n` is 0."
zero?: = 0

` "`pos?(n)` - return true if and only if number `n` is strictly positive"
pos?: > 0

` "`neg?(n)` - return true if and only if number `n` is strictly negative"
neg?: < 0

##
## Text and regexes
##
` "We don't support the usual string escapes so these make it
a little more convenient to use interpolation instead.."
ch: {
  n: "
"
  t: "	"
}

` "String processing functions"
str: {

  ` "of(e) - convert `e` to string."
  of: __STR

  ` "split(s, re) - split string `s` on separators matching regex `re`."
  split: __SPLIT

  ` "split-on(re, s) - split string `s` on separators matching regex `re`."
  split-on: split flip

  ` "join(l, s) - join list of strings `l` by interposing string s."
  join: __JOIN

  ` "join-on(s, l) - join list of strings `l` by interposing string s."
  join-on: join flip

  ` "match(s, re) - match string `s` using regex `re`, return list of full match then capture groups."
  match: __MATCH

  ` "match-with(re, s) - match string `s` using regex `re`, return list of full match then capture groups."
  match-with: match flip

  ` "matches(s, re) - return list of all matches in string `s` of regex `re`."
  matches: __MATCHES

  ` "matches-of(re, s) - return list of all matches in string `s` of regex `re`."
  matches-of: matches flip

  ` "matches?(re, s) - return true if `re` matches full string `s`."
  matches?(re, s): match(s, re) (not ∘ nil?)

  ` "suffix(b, a) - return string `b` suffixed onto `a`."
  suffix(b, a): [a, b] join-on("")

  ` "prefix(b, a) - return string `b` prefixed onto `a`."
  prefix(b, a): [b, a] join-on("")
}

##
## Combinators
##

` "`identity(v)` - identity function, return value `v`."
identity(v): v

` "`const(k)` - return single arg function that always returns k."
const(k, _): k

` "`compose(f,g,x)` - apply function `f` to `g(x)`."
compose(f, g, x): x g f

` { doc: "`(f ∘ g)` - return composition of `f` and `g`"
    export: :suppress
    associates: :right
    precedence: 88 }
(f ∘ g): compose(f,g)

` { doc: "(l @ r) - function application operator, for reversing catentation args and eliding parentheses"
    export: :suppress
    associates: :right
    precedence: :apply }
(l @ r): l(r)

` "`apply(f, xs)` - apply function `f` to arguments in list `xs`."
apply(f, xs): foldl(cat flip, f, xs)

` "`flip(f)` - flip arguments of function `f`, flip(f)(x, y) == f(y, x)"
flip(f, x, y): f(y, x)

` "`complement(p?)` - invert truth value of predicate function."
complement(p?): compose(not, p?)

` "`curry(f)` - turn f([x, y]) into f' of two parameters (x, y)."
curry(f, x, y): f([x, y])

` "`uncurry(f)` - turn f(x, y) into f' that expects [x, y] as a list."
uncurry(f, l): f(first(l), second(l))

` "`cond(l)` - in list `l` of [condition, value] select first true condition, returning value, else default `d`."
cond(l, d): foldr(l, d, curry(if))

` "`juxt(f, g) - return function of `x` returning list of `f(x)` and g(x)`."
juxt(f, g, x): [x f, x g]


#
# Metadata basics
#

` "`with-meta m e` - add metadata block `m` to expression `e`."
with-meta: __WITHMETA

` { doc: "`e // m` - add metadata block `m` to expression `e`."
    export: :suppress 
    associates: :left
    precedence: :meta }
(e // m): e with-meta(m)

` "`meta e` - retrieve expression metadata for e."
meta: __META

assertions: {
  # In debug mode maybe the machine checks every return value against
  # metadata, but for performance reasons we only check for explicit
  # assertions.

  ` "`validator(v)` - find the validator for a value `v` in its metadata"
  validator(v): lookup-or(:assert, const(true), meta(v))

  ` "`check(v)` - true if v is valid according to assert metadata"
  check(v): v validator(v)

  ` "`checked(v)` - panic if value doesn't satisfy its validator"
  checked(v): if(check(v), v, panic("Assertion failed"))
}

` { doc: "`e //= v` - add metadata to check expression `e` evaluates to `v` and return whether valid"
    export: :suppress 
    associates: :left
    precedence: :meta }
(e //= v): e with-meta({ assert: (= v)}) assertions.check

` { doc: "`e //=> v` - add metadata to assert expression `e` evaluates to `v` and return `e`."
    export: :suppress 
    associates: :left
    precedence: :meta }
(e //=> v): e with-meta({ assert: (= v)}) assertions.checked

` { doc: "`e //=? f` - add metadata to assert expression `e` satisfies predicate `f` and return `e`."
    export: :suppress 
    associates: :left
    precedence: :meta }
(e //=? f): e with-meta({ assert: f}) assertions.checked

` { doc: "`e //!? f` - add metadata to assert expression `e` does not satisfy predicate `f` and return `e`."
    export: :suppress 
    associates: :left
    precedence: :meta }
(e //!? f): e with-meta({ assert: complement(f)}) assertions.checked

` { doc: "`e //! f` - add metadata to assert expression `e` is true and return `e`."
    export: :suppress 
    precedence: :meta }
(e //!): e with-meta({ assert: (= true) }) assertions.checked

` { doc: "`e //!! f` - add metadata to assert expression `e` is false and return `e`."
    export: :suppress 
    precedence: :meta }
(e //!!): e with-meta({ assert: (= false) }) assertions.checked

#
# List library functions, maps and folds
#

` "`nil?(l)` - `true` if list `l` is empty, `false` otherwise."
nil?: = []

` "`take(n, l)` - return initial segment of integer `n` elements from list `l`."
take(n, l): __IF(n zero?, [], cons(l head, take(n dec, l tail)))
 
` "`drop(n, l)` - return result of dropping integer `n` elements from list `l`."
drop(n, l): __IF((n zero?), l, drop(n dec, l tail))

` "`nth(n, l)` - return `n`th item of list if it exists, otherwise panic."
nth(n, l): l drop(n dec) head

` { doc: "`l !! n` - return `n`th item of list if it exists, otherwise error."
    precedence: :exp }
(l !! n): l nth(n)

` "`repeat(i)` - return infinite list of instances of item `i`."
repeat(i): __CONS(i, repeat(i))

` "`foldl(op, i, l)` - left fold operator `op` over list `l` starting from value `i` "
foldl(op, i, l): if(l nil?, i, foldl(op, op(i, l head), l tail))

` "`foldr(op, i, l)` - right fold operator `op` over list `l` ending with value `i` "
foldr(op, i, l): if(l nil?, i, op(l head, foldr(op, i, l tail)))

` "`scanl(op, i, l)` - left scan operator `op` over list `l` starting from value `i` "
scanl(op, i, l): if(l nil?, [i], scanl(op, op(i, l head), l tail) cons(i)) 

` "`scanr(op, i, l)` - right scan operator `op` over list `l` ending with value `i` "
scanr(op, i, l): if(l nil?, [i], { scan: scanr(op, i, l tail) }.(cons(op(l head, scan head), scan)))

` "`iterate(f, i) - return list of `i` with subsequent repeated applications of `f` to `i`"
iterate(f, i): cons(i, iterate(f, i) map(f))

` "`count(l)` - return count of items in list `l`"
count(l): foldl({ n: • el: •}.(n inc), 0, l)

` "`map(f, l)` - map function `f` over list `l`"
map(f, l): if(l nil?, l, cons(l head f, l tail map(f)))

` { doc: "`f <$> l` - map function `f` over list `l`"
    export: :suppress 
    associates: :left 
    precedence: :map }
(f <$> l): map(f, l)

` "`map(f, l1, l2)` - map function `f` over lists `l1` and `l2`, until the shorter is exhausted."
map2(f, l1, l2): if(nil?(l1) || nil?(l2), [], cons(f(l1 head, l2 head), map2(f, l1 tail, l2 tail)))

` "`zip-with(f, l1, l2)` - map function `f` over lists `l1` and `l2`, until the shorter is exhausted."
zip-with: map2

` "`filter(p?, l)` - return list of elements of list `l` that satisfy predicate `p?`."
filter(p?, l): foldr({x: • xs: • }.(if(x p?, cons(x, xs), xs)), [], l)

` "`remove(p?, l)` - return list of elements of list `l` that do not satisfy predicate `p?`."
remove(p?, l): l filter(p? complement)

` "`append(l1, l2)` - concatenate two lists `l1` and `l2`."
append(l1, l2): foldr(cons, l2, l1)

` "`prepend(l1, l2)` - concatenate two lists with `l1` after `l2`."
prepend: flip(append)

` { doc: "`l1 ++ l2` - concatenate lists `l1` and `l2`."
    export: :suppress
    associates: :left
    precedence: :append }
(l1 ++ l2): append(l1, l2)

` "`concat(ls)` - concatenate all lists in `ls` together."
concat(ls): foldr(append, [], ls)

` "`zip-apply(fs, vs)` - apply fns in list `fs` to corresponding values in list `vs`, until shorter is exhausted."
zip-apply(fs, vs): zip-with(cat, vs, fs)

` "`reverse(l) - reverse list `l`"
reverse(l): foldl(cons flip, [], l)

` "`all-true?(l)` - true if and only if all items in list `l` are true."
all-true?(l): foldl(and, true, l)

` "`all-true?(l)` - true if and only if all items in list `l` satisfy predicate `p?`."
all(p?, l): l map(p?) all-true?

` "`any-true?(l)` - true if and only if any items in list `l` are true."
any-true?(l): foldr(or, false, l)

` "`any-true?(l)` - true if and only if any items in list `l` satisfy predicate `p?`."
any(p?, l): l map(p?) any-true?

#
# Block library functions
#

` "`merge-all(bs)` - merge all blocks in list `bs` together, later overriding earlier."
merge-all(bs): foldl(merge, {}, bs)

` "`key(pr)` - return key in a block element / pair."
key: head

` "`value(pr)` - return key in a block element / pair."
value: second

` "`keys(b)` - return keys of block"
keys(b): b elements map(key)

` "`values(b)` - return values of block"
values(b): b elements map(value)

` "`bimap(f, g, pr)` - apply f to first item of pair and g to second, return pair."
bimap(f, g, pr): [f(first(pr)), g(second(pr))]

` "`map-first(f, prs)` - apply f to first elements of all pairs in list of pairs `prs`."
map-first(f, prs): map(bimap(f, identity), prs)

` "`map-second(f, prs)` - apply f to second elements of all pairs in list of pairs `prs`."
map-second(f, prs): map(bimap(identity, f), prs)

` "`map-kv(f, b)` - apply `f(k, v)` to each key / value pair in block `b`."
map-kv(f, b): b elements map(uncurry(f)) block

` "`pair(k, v)` - form a block element from key (symbol) `k` and value `v`."
pair(k, v): [k, v]

` "`zip-kv(ks, vs)` - create a block by zipping together keys `ks` and values `vs`."
zip-kv(ks, vs): zip-with(pair, ks, vs) block

` "`with-keys(ks)` - create block from list of values by assigning list of keys `ks` against them"
with-keys: zip-kv

` "`map-values(f, b)` - apply `f(v)` to each value in block `b`."
map-values(f, b): b elements map-second(f) block

` "`map-keys(f, b)` - apply `f(k)` to each key in block `b`."
map-keys(f, b): b elements map-first(f) block

` "`select-items(f, b)` - return items from block `b` which match item match function `f`"
select-items(f, b): b elements filter(f) 

` "`by-key(p?)` - return item match function that checks predicate `p?` against the (symbol) key."
by-key(p?): p? ∘ key

` "`by-key-name(p?)` - return item match function that checks predicate `p?` against string representation of the key."
by-key-name(p?): p? ∘ str.of ∘ key

` "`by-key-match(re)` - return item match function that checks string representation of the key matches regex `re`."
by-key-match(re): by-key-name(str.matches?(re))

` "`by-value(p?) - return item match runction that checks predicate `p?` against the item value."
by-value(p?): p? ∘ value

` "`match-select-values` - return list of values from block `b` with keys matching regex `re`."
match-select-values(re, b): b select-items(by-key-match(re)) map(value)

` "`select-values(p?, b)` - return items from block `b` where values match predicate `p?`"
select-values(p?, b): b values filter(p?)

_block: {
  ` "If `k` satisfies `k?` then `v!` else `v`"
  alter?(k?, v!, k, v): [k, if(k k?, v!, v)]

  ` "If `k` satisfies `k?` then `v!` else `v`"
  update?(k?, f, k, v): [k, if(k k?, v f, v)]
}

# By property alteration of blocks

` "`alter-value(k, v, b)` - alter `b.k` to value `v`."
alter-value(k, v, b): b map-kv(_block.alter?(= k, v))

` "`update-value(k, f, b)` - update  `b.k` to `f(b.k)`."
update-value(k, f, b): b map-kv(_block.update?(= k, f))

` "`alter(ks, v, b)` - in nested block `b` alter value to value `v` at path-of-keys `ks`"
alter(ks, v, b): b foldr(update-value, const(v), ks)

` "`update(ks, f, b)` - in nested block `b` applying `f` to value at path-of-keys `ks`"
update(ks, f, b): b foldr(update-value, f, ks)

` "update-value-or(k, f, d, b) - set `b.k` to `f(v)` where v is current value, otherwise add with default value `d`."
update-value-or(k, f, d, b): {
  acc(st, el): if(k = (el key),
                  [cons([k, f(el value)], st first), []],
		  [cons(el, st first), st second])
  final-state: foldl(acc,
                     [[], [[k, d]]],
		     b elements)
  final-block: final-state (append flip uncurry) reverse block
}.final-block

` "set(k, v, b) - set `b.k` to `v`, adding if absent."
set-value(k, v): update-value-or(k, const(v), v)

` "tongue(ks, v) - construct block with a single nested path-of-keys `ks` down to value `v`"
tongue(ks, v): foldr({k: • e: •}.([[k, e]] block), v, ks) 


` "merge-at(ks, v, b) - shallow merge block `v` into block value at path-of-keys `ks`"
merge-at(ks, v, b): if(ks nil?,
                       b v,
		       b update-value-or(ks head,
		                         merge-at(ks tail, v),
					 tongue(ks tail, v)))
